!! Copyright (c) 2000, 2018 IBM Corp. and others
!!
!! This program and the accompanying materials are made available under
!! the terms of the Eclipse Public License 2.0 which accompanies this
!! distribution and is available at https://www.eclipse.org/legal/epl-2.0/
!! or the Apache License, Version 2.0 which accompanies this distribution and
!! is available at https://www.apache.org/licenses/LICENSE-2.0.
!!
!! This Source Code may also be made available under the following
!! Secondary Licenses when the conditions for such availability set
!! forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
!! General Public License, version 2 with the GNU Classpath
!! Exception [1] and GNU General Public License, version 2 with the
!! OpenJDK Assembly Exception [2].
!!
!! [1] https://www.gnu.org/software/classpath/license.html
!! [2] http://openjdk.java.net/legal/assembly-exception.html
!!
!! SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception

#include "j9cfg.h"
#include "jilconsts.inc"
#include "p/runtime/ppcasmdefines.inc"
!	.file "J9PPCArrayTranslate.s"

#ifdef AIXPPC
        .globl    .__arrayTranslateTRTO
        .globl    __arrayTranslateTRTO{DS}
        .globl    .__arrayTranslateTRTO255
        .globl    __arrayTranslateTRTO255{DS}
        .globl    .__arrayTranslateTROT255
        .globl    __arrayTranslateTROT255{DS}
        .globl    .__arrayTranslateTROT
        .globl    __arrayTranslateTROT{DS}
#if 0
	.globl    .__arrayTranslateTRTOSimpleVMX
	.globl    __arrayTranslateTRTOSimpleVMX{DS}

	.lglobl	__arrayTranslateLabelTable
	.lglobl	L.vector01001
	.lglobl	L.vector10000
	.lglobl	L.vector10001
	.lglobl	L.vector11000
	.lglobl	L.vector11001
	.lglobl	L.vector00001
	.lglobl	L.vector00010
	.lglobl	L.vector00011
	.lglobl	L.vector00100
	.lglobl	L.vector00101
	.lglobl	L.vector00110
	.lglobl	L.vector00111
	.lglobl	L.vector01000
	.lglobl	L.vector01001
	.lglobl	L.vector01010
	.lglobl	L.vector01011
	.lglobl	L.vector01100
	.lglobl	L.vector01101
	.lglobl	L.vector01110
	.lglobl	L.vector01111
	.lglobl	L.vector10000
	.lglobl	L.vector10001
	.lglobl	L.vector10010
	.lglobl	L.vector10011
	.lglobl	L.vector10100
	.lglobl	L.vector10101
	.lglobl	L.vector10110
	.lglobl	L.vector10111
	.lglobl	L.vector11000
	.lglobl	L.vector11001
	.lglobl	L.vector11010
	.lglobl	L.vector11011
	.lglobl	L.vector11100
	.lglobl	L.vector11101
	.lglobl	L.vector11110
	.lglobl	L.vector11111
#endif

#elif defined(LINUXPPC64)
        .globl    FUNC_LABEL(__arrayTranslateTRTO)
        .type     FUNC_LABEL(__arrayTranslateTRTO),@function
        .globl    FUNC_LABEL(__arrayTranslateTRTO255)
        .type     FUNC_LABEL(__arrayTranslateTRTO255),@function
        .globl    FUNC_LABEL(__arrayTranslateTROT255)
        .type     FUNC_LABEL(__arrayTranslateTROT255),@function
        .globl    FUNC_LABEL(__arrayTranslateTROT)
        .type     FUNC_LABEL(__arrayTranslateTROT),@function
#if 0
	.globl    FUNC_LABEL(__arrayTranslateTRTOSimpleVMX)
	.type     FUNC_LABEL(__arrayTranslateTRTOSimpleVMX),@function
#endif

#elif defined(LINUX) || defined(NEUTRINO)
	.globl    __arrayTranslateTRTO
	.globl    __arrayTranslateTRTO255
	.globl    __arrayTranslateTROT255
	.globl    __arrayTranslateTROT
#if 0
	.globl    __arrayTranslateTRTOSimpleVMX
#endif
#endif

#ifdef AIXPPC
! .text section
    	.align	5
	.csect    ArrayCopy_TEXT{PR}
#elif defined(LINUXPPC64)
	.section  ".text"
    	.align	5
#else
    	.align	5
#endif

!----------------------------------------------------------------------
!  Toggles which alignment method to be used for both
!  arrayTranslateTRTO255 and arrayTranslateTROT255
#define NOALIGNLOOP
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! entry arrayTranslateTRTO
!----------------------------------------------------------------------
!  Since we know we have a simple table with maximum valid character 'max', the
!  conversion process can be implmented as follows:
!
!    uint16 input[];
!    uint8  output[];
!    int len;
!    uint16 max; // Valid range 0x0000-0xffff
!
!    int i = 0;
!    while (i  < len) {
!        uint16 ch = input[i];
!        if (ch > max) break;
!        output[i] = ch & 0xff;
!        i++;
!    }
!    return i - 1;

#ifdef AIXPPC
.__arrayTranslateTRTO:
	.function .__arrayTranslateTRTO,startproc.__arrayTranslateTRTO,16,0,(endproc.__arrayTranslateTRTO-startproc.__arrayTranslateTRTO)
        .machine "push"
        .machine "pwr7"
#elif defined(LINUXPPC64)
FUNC_LABEL(__arrayTranslateTRTO):
#else
__arrayTranslateTRTO:
#endif

#if !defined(__LITTLE_ENDIAN__)
  #define FIRST_CHAR_SHIFT 16
  #define SECOND_CHAR_SHIFT 0
#else
  #define FIRST_CHAR_SHIFT 0
  #define SECOND_CHAR_SHIFT 16
#endif

!----------------------------------------------------------------------
! input:
! r3 = input ptr
! r4 = output ptr
! r5 = num_elements
! r8 = terminal character 0xff80ff80 (ASCII) or 0xff00ff00 (ISO8859)
! output:
! r3 = number_elements_processed
! r4 = output ptr
! clobbered: r5-r7, r11, vr0-vr4, cr0
    	startproc.__arrayTranslateTRTO:

        staddr          r4, -ALen(J9SP)                 ! preserve start of output buffer for later

#if defined(TR_TARGET_64BIT)
		clrldi r8, r8, 32			! 64bit mask out upper 32bits.
#endif

#ifdef ALIGNLOOP
! Alignment loop, aligns input ptr to 16 bytes
        cmpi            cr0, 0, r5, 8
        blt-            cr0, .L.__alignResidue_TRTO
.L.__alignLoop_TRTO:
        andi.           r6, r3, 0xf
        beq             cr0, .L.__main_TRTO            ! if clear, we are aligned
        lhz             r6, 0(r3)
        andi.           r7, r6, 0xff00
        bne-            cr0, .L.__done_TRTO            ! element has bits in 0xff00, we are done
        stb             r6, 0(r4)
        addi            r3, r3, 2
        addi            r4, r4, 1
        addi            r5, r5, -1
        cmpli           cr0, 0, r5, 0
        bne             cr0, .L.__alignLoop_TRTO
        b               .L.__done_TRTO
#else

        cmpli           cr0, 0, r5, 23                  ! if we have less than 23 elements, go straight to residue
        blt             cr0, .L.__alignResidue_TRTO       ! since vector loop needs >= 16 and this decision tree needs >= 7

        andi.           r6, r3, 0x2                     ! if set, input alignment is one of 2, 6, 10, 14
        beq             cr0, .L.__test4_TRTO
        lhz             r6, 0(r3)
        and.           	r7, r6, r8
        bne-            cr0, .L.__done_TRTO
        stb             r6, 0(r4)
        addi            r3, r3, 2                       ! input alignment is now one of 4, 8, 12, 16
        addi            r4, r4, 1
        addi            r5, r5, -1
.L.__test4_TRTO:
        andi.           r6, r3, 0x4                     ! if set, input alignment is one of 4, 12
        beq             cr0, .L.__test8_TRTO
        
        lwz             r6, 0(r3)
        rlwinm          r7, r6, FIRST_CHAR_SHIFT, 16, 31   ! get first char from word
        and.            r11, r7, r8
        bne-            cr0, .L.__done_TRTO
        stb             r7, 0(r4)
        addi            r4, r4, 1
        rlwinm          r6, r6, SECOND_CHAR_SHIFT, 16, 31  ! get second char from word
        and.            r11, r6, r8   
        bne-            cr0, .L.__done_TRTO
        stb             r6, 0(r4)
        addi            r4, r4, 1
        
        addi            r3, r3, 4                       ! input alignment is now one of 8, 16
        addi            r5, r5, -2
.L.__test8_TRTO:
        andi.           r6, r3, 0x8                     ! if set, input alignment is 8
        beq             cr0, .L.__main_TRTO
        
        lwz             r6, 0(r3)
        rlwinm          r7, r6, FIRST_CHAR_SHIFT, 16, 31   ! get 1st char from word
        and.            r11, r7, r8
        bne-            cr0, .L.__done_TRTO
        stb             r7, 0(r4)
        addi            r4, r4, 1
        rlwinm          r6, r6, SECOND_CHAR_SHIFT, 16, 31  ! get 2nd char from word
        and.            r11, r6, r8   
        bne-            cr0, .L.__done_TRTO
        stb             r6, 0(r4)
        addi            r4, r4, 1
           
        lwz             r6, 4(r3)
        rlwinm          r7, r6, FIRST_CHAR_SHIFT, 16, 31   ! get 1st char from 2nd word
        and.            r11, r7, r8
        bne-            cr0, .L.__done_TRTO
        stb             r7, 0(r4)
        addi            r4, r4, 1
        rlwinm          r6, r6, SECOND_CHAR_SHIFT, 16, 31  ! get 2nd char from 2nd word
        and.            r11, r6, r8   
        bne-            cr0, .L.__done_TRTO
        stb             r6, 0(r4)
        addi            r4, r4, 1

        addi            r3, r3, 8                       ! input alignment is now 16
        addi            r5, r5, -4
#endif

.L.__main_TRTO:
#ifdef ALIGNLOOP
        rlwinm.         r6, r5, 32-4, 4, 31             ! r6 = num_elements / 16, processed in vector loop
        beq             cr0, .L.__alignResidue_TRTO       ! if <16 elements, goto residue
#else
        rlwinm          r6, r5, 32-4, 4, 31             ! r6 = num_elements / 16, processed in vector loop
#endif

! Vector loop, 16 elements per iter
        mtctr           r6
        rlwinm          r5, r5, 0, 28, 31               ! r5 = num_elements % 16, processed in residue loop

#if !defined(__LITTLE_ENDIAN__)
        lvsl            vr0, r0, r3                     ! vr0 = 0x000102030405060708090a0b0c0d0e0f, since r3 & 15 == 0
        vspltisb        vr5, 1                          ! vr1 = 16*{1}
        vslb            vr1, vr0, vr5                   ! vr1 = 0x00020406080a0c0e10121416181a1c1e = permute control vector upper byte
        vaddubs		vr5, vr1, vr5			! vr5 - 0x01030507090b0d0f11131417191b1d1f = permute control vector lower byte

        vspltisb        vr0, 4                          ! vr0 = 16*{4}
       	extrwi		r6, r8, 4, 8			! r6 = 0x8 or 0x0, extract 4 bits starting at position 8 out of 0xff80 or 0xff00
        lvsl            vr6, 0, r6
        vspltb		vr6, vr6, 0

        vslb		vr6, vr6, vr0			! vr6 = 16*{0x80} or 16*{0x00}	- Lower byte mask
        vspltisw        vr0, 0                          ! vr0 = 0			- Upper byte mask
        li              r6, 16
        li              r7, 8

.L.__vectorLoop_TRTO:
        lvx             vr2, r0, r3                     ! load elements 0-7
        lvx             vr3, r3, r6                     ! load elements 8-15
        vperm           vr4, vr2, vr3, vr1              ! vr4 now contains high byte of elements 0-15
        vperm		vr7, vr2, vr3, vr5		! vr7 now contains  low byte of elements 0-15
       	vand		vr7, vr7, vr6			! vr7 will contain bits of low byte of element masked with 0x00 or 0x80
        vor vr4, vr4, vr7			! vr4 will be non-zero if any element has bits in 0xff00 or 0xff80
        vcmpequh_r   vr4, vr4, vr0
        bge-            cr6, .L.__vectorResidue_TRTO      ! if !cr[lt], i.e. ge, at least one element has bits in 0xff00 or 0xff80, goto residue
                                                        ! At this point we know all elements are 8 bits long
        vpkuhus         vr2, vr2, vr3                   ! pack all 16 elements
#ifdef VSXSTORES
        ! VSX 8-byte stores perform very poorly on P7
        xxpermdi        vs35, vs34, vs34, 2             ! swap elements 0-7 with 8-15
        stxsdx          vs34, r0, r4                    ! store elements 0-7
        stxsdx          vs35, r4, r7                    ! store elements 8-15
#else
        xxlor           vs0, vs34, vs34                 ! move to fp0
        xxpermdi        vs1, vs34, vs34, 2              ! swap elements 0-7 with 8-15, move to fp1
        stfdx           fp0, r0, r4                     ! store elements 0-7
        stfdx           fp1, r4, r7                     ! store elements 8-15
#endif

#else
        ! Little Endian path
        vspltisb        vr1, 0x1f             ! vr1 = 16*{0xff}               - Upper byte mask

        vspltisb        vr4, 4              ! vr4 = 16*{4}
       	extrwi		r6, r8, 4, 8			! r6 = 0x8 or 0x0, extract 4 bits starting at position 8 out of 0xff80 or 0xff00
        lvsl            vr5, r0, r6
        vspltb		vr5, vr5, 0
        vslb		vr5, vr5, vr4			! vr5 = 16*{0x80} or 16*{0x00}	- Lower byte mask

        vmrghb      vr1, vr1, vr5           ! vr1 = 8*{0xff80} or 8*{0xff00} - Halfword mask
        vandc       vr0, vr0, vr0           ! vr0 = 16*{0}
        vspltisw        vr6, 0x10            ! vr6 = 4*{-16} - this is used to shift by 16 bits later
        li              r6, 16
        li              r7, 8

.L.__vectorLoop_TRTO:
        lxvw4x             vs34, r0, r3                     ! load elements 0-7
        lxvw4x             vs35, r3, r6                     ! load elements 8-15
       	vand		vr4, vr2, vr1                     ! check elements 0-7 against the mask
       	vand		vr5, vr3, vr1                     ! check elements 8-15 against the mask
        vor vr4, vr4, vr5			! vr4 will be non-zero if any element has bits in 0xff00 or 0xff80
        vcmpequh_r   vr4, vr4, vr0
        bge-            cr6, .L.__vectorResidue_TRTO      ! if !cr[lt], i.e. ge, at least one element has bits in 0xff00 or 0xff80, goto residue
                                                        ! At this point we know all elements are 8 bits long
        vpkuhus         vr2, vr2, vr3                   ! pack all 16 elements
        vrlw            vr2, vr2, vr6                   ! fix byte ordering for a little endian store
        stxvw4x         vs34, r0, r4                     ! store elements 0-15

        ! End Little Endian Path
#endif
        addi            r3, r3, 32                      ! bump input ptr
        addi            r4, r4, 16                      ! bump output ptr
        bdnz            .L.__vectorLoop_TRTO

! Residue loop, single element per iter
.L.__vectorResidue_TRTO:
        mfctr           r6
        rlwimi.         r5, r6, 4, 0, 27                ! add remaining elements from vector loop to residue loop
        beq             cr0, .L.__done_TRTO               ! if 0 elements left, we are done
.L.__alignResidue_TRTO:
        mtctr           r5
        addi            r3, r3, -2                      ! adjust so we can use lhzu
.L.__residueLoop_TRTO:
        lhzu            r5, 2(r3)
        and.	        r6, r5, r8
        bne-            .L.__done_TRTO
        stb             r5, 0(r4)
        addi            r4, r4, 1
        bdnz            .L.__residueLoop_TRTO

.L.__done_TRTO:
        laddr           r5, -ALen(J9SP)
        subf            r3, r5, r4                      ! r3 = output_ptr - output_base_ptr = num_elements_processed
        blr

#ifdef AIXPPC
        .machine "pop"
#endif
    	endproc.__arrayTranslateTRTO:

#ifdef AIXPPC
.__arrayTranslateTRTO255:
	.function .__arrayTranslateTRTO255,startproc.__arrayTranslateTRTO255,16,0,(endproc.__arrayTranslateTRTO255-startproc.__arrayTranslateTRTO255)
        .machine "push"
        .machine "pwr7"
#elif defined(LINUXPPC64)
FUNC_LABEL(__arrayTranslateTRTO255):
#else
__arrayTranslateTRTO255:
#endif
! input:
! r3 = input ptr
! r4 = output ptr
! r5 = num_elements
! output:
! r3 = number_elements_processed
! clobbered: r4-r6, r11, vr0-vr4, cr0, cr6, fp0-fp1 ifndef VSXSTORES
    	startproc.__arrayTranslateTRTO255:

#if !defined(__LITTLE_ENDIAN__)
        staddr          r4, -ALen(J9SP)         ! preserve start of output buffer for later

#ifdef ALIGNLOOP
! Alignment loop, aligns input ptr to 16 bytes
        cmpi            cr0, 0, r5, 8
        blt-            cr0, .L__simple_TRTO255
.L__alignLoop_TRTO255:
        andi.           r6, r3, 0xf
        beq             cr0, .L__main_TRTO255   ! if clear, we are aligned
        lhz             r6, 0(r3)
        andi.           r11, r6, 0xff00
        bne-            cr0, .L__done_TRTO255   ! element has bits in 0xff00, we are done
        stb             r6, 0(r4)
        addi            r3, r3, 2
        addi            r4, r4, 1
        addi            r5, r5, -1
        cmpli           cr0, 0, r5, 0
        bne             cr0, .L__alignLoop_TRTO255
        b               .L__done_TRTO255
#else
        cmpli           cr0, 0, r5, 23          ! if we have less than 23 elements, go straight to residue
        blt-            cr0, .L__simple_TRTO255   ! since vector loop needs >= 16 and this decision tree needs >= 7

        andi.           r6, r3, 0x2             ! if set, input alignment is one of 2, 6, 10, 14
        beq             cr0, .L__test4_TRTO255
        lhz             r6, 0(r3)
        andi.           r11, r6, 0xff00
        bne-            cr0, .L__done_TRTO255
        stb             r6, 0(r4)
        addi            r3, r3, 2               ! input alignment is now one of 4, 8, 12, 16
        addi            r4, r4, 1
        addi            r5, r5, -1
.L__test4_TRTO255:
        andi.           r6, r3, 0x4             ! if set, input alignment is one of 4, 12
        beq             cr0, .L__test8_TRTO255
        lwz             r6, 0(r3)
        rlwinm          r6, r6, 16, 0, 31
        andi.           r11, r6, 0xff00
        bne-            cr0, .L__done_TRTO255
        stb             r6, 0(r4)
        andis.          r11, r6, 0xff00
        addi            r4, r4, 1
        bne-            cr0, .L__done_TRTO255
        rlwinm          r6, r6, 32-16, 16, 31
        stb             r6, 0(r4)
        addi            r3, r3, 4               ! input alignment is now one of 8, 16
        addi            r4, r4, 1
        addi            r5, r5, -2
.L__test8_TRTO255:
        andi.           r6, r3, 0x8             ! if set, input alignment is 8
        beq             cr0, .L__main_TRTO255
        lwz             r6, 0(r3)
        rlwinm          r6, r6, 16, 0, 31
        andi.           r11, r6, 0xff00
        bne-            cr0, .L__done_TRTO255
        stb             r6, 0(r4)
        andis.          r11, r6, 0xff00
        addi            r4, r4, 1
        bne-            cr0, .L__done_TRTO255
        rlwinm          r6, r6, 32-16, 16, 31
        stb             r6, 0(r4)
        lwz             r6, 4(r3)
        rlwinm          r6, r6, 16, 0, 31
        andi.           r11, r6, 0xff00
        addi            r4, r4, 1
        bne-            cr0, .L__done_TRTO255
        stb             r6, 0(r4)
        andis.          r11, r6, 0xff00
        addi            r4, r4, 1
        bne-            cr0, .L__done_TRTO255
        rlwinm          r6, r6, 32-16, 16, 31
        stb             r6, 0(r4)
        addi            r3, r3, 8               ! input alignment is now 16
        addi            r4, r4, 1
        addi            r5, r5, -4
#endif

.L__main_TRTO255:
#ifdef ALIGNLOOP
        rlwinm.         r6, r5, 32-4, 4, 31     ! r6 = num_elements / 16, processed in vector loop
        beq             cr0, .L__alignResidue_TRTO255   ! if <16 elements, goto residue
#else
        rlwinm          r6, r5, 32-4, 4, 31     ! r6 = num_elements / 16, processed in vector loop
#endif

! Vector loop, 16 elements per iter
        mtctr           r6
        rlwinm          r5, r5, 0, 28, 31       ! r5 = num_elements % 16, processed in residue loop
        li              r6, 16
        li              r11, 8
        lvsl            vr0, r0, r3             ! vr0 = 0x000102030405060708090a0b0c0d0e0f, since r3 & 15 == 0
        vspltisb        vr1, 1                  ! vr1 = 16*{1}
        vslb            vr1, vr0, vr1           ! vr1 = 0x00020406080a0c0e10121416181a1c1e = permute control vector
        vspltisw        vr0, 0                  ! vr0 = 0
.L__vectorLoop_TRTO255:
        lvx             vr2, r0, r3             ! load elements 0-7
        lvx             vr3, r3, r6             ! load elements 8-15
        vperm           vr4, vr2, vr3, vr1      ! vr4 now contains high byte of elements 0-15
        vcmpequh_r      vr4, vr4, vr0           ! cmp high bytes against 0, cr6[lt] set if all clear
        bge-            cr6, .L__vectorResidue_TRTO255  ! if !cr[lt], i.e. ge, at least one element has bits in 0xff00, goto residue
                                                ! At this point we know all elements are 8 bits long
        vpkuhus         vr2, vr2, vr3           ! pack all 16 elements
#ifdef VSXSTORES
        ! VSX 8-byte stores perform very poorly on P7
        xxpermdi        vs35, vs34, vs34, 2     ! swap elements 0-7 with 8-15
        stxsdx          vs34, r0, r4            ! store elements 0-7
        stxsdx          vs35, r4, r11           ! store elements 8-15
#else
        xxlor           vs0, vs34, vs34         ! move to fp0
        xxpermdi        vs1, vs34, vs34, 2      ! swap elements 0-7 with 8-15, move to fp1
        stfdx           fp0, r0, r4             ! store elements 0-7
        stfdx           fp1, r4, r11            ! store elements 8-15
#endif
        addi            r3, r3, 32              ! bump input ptr
        addi            r4, r4, 16              ! bump output ptr
        bdnz            .L__vectorLoop_TRTO255

! Residue loop, single element per iter
.L__vectorResidue_TRTO255:
        mfctr           r6
        rlwimi          r5, r6, 4, 0, 27        ! add remaining elements from vector loop to residue loop
.L__simple_TRTO255:
        cmpi            cr0, 0, r5, 0
        beq             cr0, .L__done_TRTO255   ! if 0 elements left, we are done
.L__alignResidue_TRTO255:
        mtctr           r5
        addi            r3, r3, -2              ! adjust so we can use lhzu
.L__residueLoop_TRTO255:
        lhzu            r5, 2(r3)
        andi.           r6, r5, 0xff00
        bne-            .L__done_TRTO255
        stb             r5, 0(r4)
        addi            r4, r4, 1
        bdnz            .L__residueLoop_TRTO255

.L__done_TRTO255:
        laddr           r5, -ALen(J9SP)
        subf            r3, r5, r4              ! r3 = output_ptr - output_base_ptr = num_elements_processed
        blr
#else
        ! Don`t need LE support for this
        trap
#endif
#ifdef AIXPPC
        .machine "pop"
#endif
    	endproc.__arrayTranslateTRTO255:

!----------------------------------------------------------------------
! entry arrayTranslateTROT255
!----------------------------------------------------------------------
!  Since we know we have a simple table with maximum valid character max, the
!  conversion process can be implmented as follows:
!
!    uint8   input[];
!    uint16  output[];
!    int len;
!    uint16 max; // Valid range 0x0000-0xffff
!
!    int i = 0;
!    while (i  < len) {
!        output[i] = input[i] & 0xff;
!        i++;
!    }
!    return i - 1;

#ifdef AIXPPC
.__arrayTranslateTROT255:
	.function .__arrayTranslateTROT255,startproc.__arrayTranslateTROT255,16,0,(endproc.__arrayTranslateTROT255-startproc.__arrayTranslateTROT255)
        .machine "push"
        .machine "pwr7"
#elif defined(LINUXPPC64)
FUNC_LABEL(__arrayTranslateTROT255):
#else
__arrayTranslateTROT255:
#endif
!----------------------------------------------------------------------
! input:
! r3 = input ptr
! r4 = output ptr
! r5 = num_elements
! output:
! r3 = number_elements_processed
! r4 = output ptr
! clobbered: r5-r11, vr0-vr4, cr0
#if !defined(__LITTLE_ENDIAN__)
    	startproc.__arrayTranslateTROT255:

#define tempReg1        r7
#define tempReg2        r8
#define tempReg3        r9
#define tempReg4        r10
#define tempReg5        r11

      staddr          r5, -ALen(J9SP)             ! make a copy of num elements processed

      cmpi            cr0, 0, r5, 16
      blt             cr0, .L.__simple_TROT255

      lis             tempReg4, 0x00ff
      ori             tempReg4, tempReg4, 0x00ff
	  
      andi.           r6, r3, 0xf                       ! if set, input alignment is at 8 bytes.
      beq             cr0, .L.__main_TROT255

      !Not 16 byte aligned.
.L.__test1_TROT255:
      cmpi            cr0, 0, r5, 1			! are there 1 or more bytes left?
      blt             cr0, .L.__done_TROT255		! false, done
      andi.           r6, r3, 0x1                       ! if set, input is aligned at an odd byte.
      beq	      cr0, .L.__test2_TROT255
.L.__dotest1_TROT255:
      lbz             r6, 0(r3)
      sth             r6, 0(r4)
      addi            r3, r3, 1
      addi            r4, r4, 2
      addi            r5, r5, -1
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT255
.L.__test2_TROT255:					! aligned at 2 bytes.
      cmpi            cr0, 0, r5, 2			! are there 2 or more bytes left?
      blt             cr0, .L.__residue_TROT255		! false, goto residue
      andi.           r6, r3, 0x3                       ! check if input is aligned at 4 bytes.
      beq             cr0, .L.__test4_TROT255
.L.__dotest2_TROT255:
      lhz             r6, 0(r3)                         ! Suppose R6 = 0x0000cafe
      insrwi          r6, r6, 16, 8                     ! get R6 = 0x00cafefe
      and             r6, r6, tempReg4                  ! get R6 = 0x00cafefe & 0x00ff00ff = 0x00ca00fe
      stw             r6, 0(r4)
      addi            r3, r3, 2
      addi            r4, r4, 4
      addi            r5, r5, -2
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT255
.L.__test4_TROT255:
      cmpi            cr0, 0, r5, 4			! are there 4 or more bytes left?
      blt             cr0, .L.__residue_TROT255	        ! false, goto residue
      andi.           r6, r3, 0x7                       ! check if input is aligned at 8 bytes.
      beq             cr0, .L.__test8_TROT255
.L.__dotest4_TROT255:
      lhz             r6, 0(r3)                         ! suppose R6 = 0xcafe
      lhz             tempReg1, 2(r3)                   ! get tempReg1 = 0xbabe rest is same as above.
      insrwi          r6, r6, 16, 8
      insrwi          tempReg1, tempReg1, 16, 8
      and             r6, r6, tempReg4
      and             tempReg1, tempReg1, tempReg4
      stw             r6, 0(r4)
      stw             tempReg1, 4(r4)
      addi            r3, r3, 4
      addi            r4, r4, 8
      addi            r5, r5, -4
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT255
.L.__test8_TROT255:
      cmpi            cr0, 0, r5, 8			! are there 8 or more bytes left?
      blt             cr0, .L.__residue_TROT255		! false, goto residue
      andi.           r6, r3, 0xf                       ! check if input is aligned at 16 bytes.
      beq             cr0, .L.__main_TROT255
.L.__dotest8_TROT255:
#if defined(TR_TARGET_64BIT)
     ld              r6, 0(r3)
     clrldi		  tempReg3, r6, 48					!Clear leftmost 48 bits, leave low 16 bits intact.
     extrdi          tempReg2, r6, 16, 32
     extrdi          tempReg1, r6, 16, 16
     extrdi          r6,       r6, 16, 0
#else
     lhz             r6, 0(r3)
     lhz             tempReg1, 2(r3)
     lhz             tempReg2, 4(r3)
     lhz             tempReg3, 6(r3)
#endif
      insrwi          r6,       r6, 16, 8
      insrwi          tempReg1, tempReg1, 16, 8
      insrwi          tempReg2, tempReg2, 16, 8
      insrwi          tempReg3, tempReg3, 16, 8
      and             r6, r6, tempReg4
      and             tempReg1, tempReg1, tempReg4
      and             tempReg2, tempReg2, tempReg4
      and             tempReg3, tempReg3, tempReg4
      stw             r6, 0(r4)
      stw             tempReg1, 4(r4)
      stw             tempReg2, 8(r4)
      stw             tempReg3, 12(r4)

      addi            r3, r3, 8
      addi            r4, r4, 16
      addi            r5, r5, -8
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT255

.L.__main_TROT255:
	cmpi			cr0, 0, r5, 16					! are there 16 or more bytes left?
	blt             cr0, .L.__residue_TROT255			! false, goto residue

	rlwinm          r6, r5, 32-4, 4, 31             ! r6 = num_elements / 16, processed in vector loop
	mtctr           r6
	rlwinm          r5, r5, 0, 28, 31               ! r5 = num_elements % 16, processed in residue loop

	vandc vr0, vr0, vr0								! vr0 = 0x00000000000000000000000000000000
	li r7, 0
	lvsr vr1, 0, r7									! vr1 = 0x101112131415161718191a1b1c1d1e1f
	vmrghb vr3, vr0, vr1							! vr3 = 0x00100011001200130014001500160017

	li  r7, 8
	li  r8, 16
	li  r9, 24

.L.__vectorLoop_TROT255:
	lfd				fp0, 0(r3)						! load elements 0-7
	lfd				fp1, 8(r3)						! load elements 8-15
	xxlor			vs33, vs0, vs0					! move over to VMX registers.
	xxlor			vs34, vs1, vs1
	vperm			vr1, vr0, vr1, vr3				! unpack high 8 bytes into 16 bytes.
	vperm			vr2, vr0, vr2, vr3				! unpack  low 8 bytes into 16 bytes.

	#ifdef VSXSTORES
		xxlor			vs0, vs33, vs33					! move to fp0
		xxpermdi		vs1, vs33, vs33, 2				! swap elements 0-7 with 8-15, move to fp1b
		xxlor			vs2, vs34, vs34					! move to fp2
		xxpermdi		vs3, vs34, vs34, 2				! swap elements 16-23 with 24-31, move to fp3

		stfdx           fp0,  0, r4                     ! store elements 0-7
	    stfdx           fp1, r7, r4                     ! store elements 8-15
		stfdx           fp2, r8, r4                     ! store elements 16-23
	    stfdx           fp3, r9, r4                     ! store elements 24-31
	#else
	    xxlor           vs0, vs33, vs33                 ! move to fp0
	    xxpermdi        vs1, vs33, vs33, 2              ! swap elements 0-7 with 8-15, move to fp1
	    xxlor           vs2, vs34, vs34                 ! move to fp2
	    xxpermdi        vs3, vs34, vs34, 2              ! swap elements 0-7 with 8-15, move to fp3

		stfdx           fp0,  0, r4                     ! store elements 0-7
	    stfdx           fp1, r7, r4                     ! store elements 8-15
		stfdx           fp2, r8, r4                     ! store elements 16-23
	    stfdx           fp3, r9, r4                     ! store elements 24-31
	#endif
    addi            r3, r3, 16                      ! bump input ptr
    addi            r4, r4, 32                      ! bump output ptr
    bdnz            .L.__vectorLoop_TROT255

.L.__simple_TROT255:
	cmpi            cr0, 0, r5, 0
	beq             cr0, .L.__done_TROT255			! exit if done with input
.L.__residue_TROT255:
      lbz             r6, 0(r3)
      sth             r6, 0(r4)
      addi            r3, r3, 1
      addi            r4, r4, 2
      addi            r5, r5, -1
      cmpi            cr0, 0, r5, 0
      bne             cr0, .L.__residue_TROT255

.L.__done_TROT255:
	laddr           r3, -ALen(J9SP)					! Return number of elements processed.
    blr

#ifdef AIXPPC
        .machine "pop"
#endif
    	endproc.__arrayTranslateTROT255:

#else

    	startproc.__arrayTranslateTROT255:

#define tempReg1        r7
#define tempReg2        r8
#define tempReg3        r9
#define tempReg4        r10
#define tempReg5        r11

      staddr          r5, -ALen(J9SP)             ! make a copy of num elements processed

      cmpi            cr0, 0, r5, 16
      blt             cr0, .L.__simple_TROT255

      lis             tempReg4, 0x00ff
      ori             tempReg4, tempReg4, 0x00ff

      andi.           r6, r3, 0xf                       ! if set, input alignment is at 8 bytes.
      beq             cr0, .L.__main_TROT255

      !Not 16 byte aligned.
.L.__test1_TROT255:
      cmpi            cr0, 0, r5, 1			! are there 1 or more bytes left?
      blt             cr0, .L.__done_TROT255		! false, done
      andi.           r6, r3, 0x1                       ! if set, input is aligned at an odd byte.
      beq	      cr0, .L.__test2_TROT255
.L.__dotest1_TROT255:
      lbz             r6, 0(r3)
      sth             r6, 0(r4)
      addi            r3, r3, 1
      addi            r4, r4, 2
      addi            r5, r5, -1
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT255
.L.__test2_TROT255:					! aligned at 2 bytes.
      cmpi            cr0, 0, r5, 2			! are there 2 or more bytes left?
      blt             cr0, .L.__residue_TROT255		! false, goto residue
      andi.           r6, r3, 0x3                       ! check if input is aligned at 4 bytes.
      beq             cr0, .L.__test4_TROT255
.L.__dotest2_TROT255:
      lhz             r6, 0(r3)                         ! Suppose R6 = 0x0000cafe
      insrwi          r6, r6, 16, 8                     ! get R6 = 0x00cafefe
      and             r6, r6, tempReg4                  ! get R6 = 0x00cafefe & 0x00ff00ff = 0x00ca00fe
      stw             r6, 0(r4)
      addi            r3, r3, 2
      addi            r4, r4, 4
      addi            r5, r5, -2
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT255
.L.__test4_TROT255:
      cmpi            cr0, 0, r5, 4			! are there 4 or more bytes left?
      blt             cr0, .L.__residue_TROT255	        ! false, goto residue
      andi.           r6, r3, 0x7                       ! check if input is aligned at 8 bytes.
      beq             cr0, .L.__test8_TROT255
.L.__dotest4_TROT255:
      lhz             r6, 0(r3)                         ! suppose R6 = 0xcafe
      lhz             tempReg1, 2(r3)                   ! get tempReg1 = 0xbabe rest is same as above.
      insrwi          r6, r6, 16, 8
      insrwi          tempReg1, tempReg1, 16, 8
      and             r6, r6, tempReg4
      and             tempReg1, tempReg1, tempReg4
      stw             r6, 0(r4)
      stw             tempReg1, 4(r4)
      addi            r3, r3, 4
      addi            r4, r4, 8
      addi            r5, r5, -4
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT255
.L.__test8_TROT255:
      cmpi            cr0, 0, r5, 8			! are there 8 or more bytes left?
      blt             cr0, .L.__residue_TROT255		! false, goto residue
      andi.           r6, r3, 0xf                       ! check if input is aligned at 16 bytes.
      beq             cr0, .L.__main_TROT255
.L.__dotest8_TROT255:
#if defined(TR_TARGET_64BIT)
     ld              r6, 0(r3)
     extrdi          tempReg3, r6, 16, 0
     extrdi          tempReg2, r6, 16, 16
     extrdi          tempReg1, r6, 16, 32
     clrldi          r6, r6, 48					!Clear leftmost 48 bits, leave low 16 bits intact.
#else
     lhz             r6, 0(r3)
     lhz             tempReg1, 2(r3)
     lhz             tempReg2, 4(r3)
     lhz             tempReg3, 6(r3)
#endif
      insrwi          r6,       r6, 16, 8
      insrwi          tempReg1, tempReg1, 16, 8
      insrwi          tempReg2, tempReg2, 16, 8
      insrwi          tempReg3, tempReg3, 16, 8
      and             r6, r6, tempReg4
      and             tempReg1, tempReg1, tempReg4
      and             tempReg2, tempReg2, tempReg4
      and             tempReg3, tempReg3, tempReg4
      stw             r6, 0(r4)
      stw             tempReg1, 4(r4)
      stw             tempReg2, 8(r4)
      stw             tempReg3, 12(r4)

      addi            r3, r3, 8
      addi            r4, r4, 16
      addi            r5, r5, -8
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT255

.L.__main_TROT255:
	cmpi			cr0, 0, r5, 16					! are there 16 or more bytes left?
	blt             cr0, .L.__residue_TROT255			! false, goto residue

	rlwinm          r6, r5, 32-4, 4, 31             ! r6 = num_elements / 16, processed in vector loop
	mtctr           r6
	rlwinm          r5, r5, 0, 28, 31               ! r5 = num_elements % 16, processed in residue loop

	vandc vr0, vr0, vr0								! vr0 = 0x00000000000000000000000000000000

	li  r6, 16
    vspltisw        vr3, 0x10            ! vr6 = 4*{-16} - this is used to shift by 16 bits later

.L.__vectorLoop_TROT255:
    lxvw4x          vs33, r0, r3
    vrlw            vr1, vr1, vr3                   ! fix byte ordering for a little endian load
	vmrghb          vr2, vr0, vr1
	vmrglb          vr1, vr0, vr1

    stxvw4x         vs34, r0, r4                     ! store elements 0-7
    stxvw4x         vs33, r4, r6                    ! store elements 8-15

    addi            r3, r3, 16                      ! bump input ptr
    addi            r4, r4, 32                      ! bump output ptr
    bdnz            .L.__vectorLoop_TROT255

.L.__simple_TROT255:
	cmpi            cr0, 0, r5, 0
	beq             cr0, .L.__done_TROT255			! exit if done with input
.L.__residue_TROT255:
      lbz             r6, 0(r3)
      sth             r6, 0(r4)
      addi            r3, r3, 1
      addi            r4, r4, 2
      addi            r5, r5, -1
      cmpi            cr0, 0, r5, 0
      bne             cr0, .L.__residue_TROT255

.L.__done_TROT255:
	laddr           r3, -ALen(J9SP)					! Return number of elements processed.
    blr

#ifdef AIXPPC
        .machine "pop"
#endif
    	endproc.__arrayTranslateTROT255:

#endif


!----------------------------------------------------------------------
! entry arrayTranslateTROT
!----------------------------------------------------------------------
!  Since we know we have a simple table with maximum valid character 'max', the
!  conversion process can be implmented as follows:
!
!    uint8   input[];
!    uint16  output[];
!    int len;
!    uint16 max; // Valid range 0x0000-0xffff
!
!    int i = 0;
!    while (i  < len) {
!        if(input[i] < 0) break;
!        output[i] = input[i] & 0x7f;
!        i++;
!    }
!    return i - 1;

#ifdef AIXPPC
.__arrayTranslateTROT:
	.function .__arrayTranslateTROT,startproc.__arrayTranslateTROT,16,0,(endproc.__arrayTranslateTROT-startproc.__arrayTranslateTROT)
        .machine "push"
        .machine "pwr7"
#elif defined(LINUXPPC64)
FUNC_LABEL(__arrayTranslateTROT):
#else
__arrayTranslateTROT:
#endif
!----------------------------------------------------------------------
! input:
! r3 = input ptr
! r4 = output ptr
! r5 = num_elements
! output:
! r3 = number_elements_processed
! r4 = output ptr
! clobbered: r5-r11, vr0-vr4, cr0
#if !defined(__LITTLE_ENDIAN__)
    	startproc.__arrayTranslateTROT:

        staddr          r3, -ALen(J9SP)                ! preserve start of output buffer for later

        cmpi            cr0, 0, r5, 16
        blt             cr0, .L.__simple_TROT

      	lis		tempReg4, 0x00ff
      	lis	        tempReg5, 0x8080
      	ori	        tempReg4, tempReg4, 0x00ff
      	ori	        tempReg5, tempReg5, 0x8080

      andi.           r6, r3, 0xf                       ! if set, input alignment is at 8 bytes.
      beq             cr0, .L.__main_TROT

      !Not 16 byte aligned
      !This is both entry and exit alignment/residue code.
.L.__test1_TROT:
      cmpi            cr0, 0, r5, 1			! are there 1 or more bytes left?
      blt             cr0, .L.__done_TROT		! false, done
      andi.           r6, r3, 0x1                       ! if set, input is aligned at an odd byte.
      beq	      cr0, .L.__test2_TROT
.L.__dotest1_TROT:
      lbz             r6, 0(r3)
      and.			  tempReg1, r6, tempReg5
      bne             cr0, .L.__done_TROT		!Skip going to residue, no point
      sth             r6, 0(r4)
      addi            r3, r3, 1
      addi            r4, r4, 2
      addi            r5, r5, -1
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT
.L.__test2_TROT:					! aligned at 2 bytes.
      cmpi            cr0, 0, r5, 2			! are there 2 or more bytes left?
      blt             cr0, .L.__residue_TROT		! false, goto residue
      andi.           r6, r3, 0x3                       ! check if input is aligned at 4 bytes.
      beq             cr0, .L.__test4_TROT
.L.__dotest2_TROT:
      lhz             r6, 0(r3)                         ! Suppose R6 = 0x0000cafe
      and.			  tempReg1, r6, tempReg5
      bne             cr0, .L.__residue_TROT
      insrwi          r6, r6, 16, 8                     ! get R6 = 0x00cafefe
      and             r6, r6, tempReg4                  ! get R6 = 0x00cafefe & 0x00ff00ff = 0x00ca00fe
      stw             r6, 0(r4)
      addi            r3, r3, 2
      addi            r4, r4, 4
      addi            r5, r5, -2
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT
.L.__test4_TROT:
      cmpi            cr0, 0, r5, 4			! are there 4 or more bytes left?
      blt             cr0, .L.__residue_TROT	        ! false, goto residue
      andi.           r6, r3, 0x7                       ! check if input is aligned at 8 bytes.
      beq             cr0, .L.__test8_TROT
.L.__dotest4_TROT:
      lhz             r6, 0(r3)                         ! suppose R6 = 0xcafe
      and.			  tempReg1, r6, tempReg5
      bne             cr0, .L.__residue_TROT
      lhz             tempReg1, 2(r3)                   ! get tempReg1 = 0xbabe rest is same as above.
      and.			  tempReg2, tempReg1, tempReg5
      bne             cr0, .L.__residue_TROT
      insrwi          r6, r6, 16, 8
      insrwi          tempReg1, tempReg1, 16, 8
      and             r6, r6, tempReg4
      and             tempReg1, tempReg1, tempReg4
      stw             r6, 0(r4)
      stw             tempReg1, 4(r4)
      addi            r3, r3, 4
      addi            r4, r4, 8
      addi            r5, r5, -4
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT
.L.__test8_TROT:
      cmpi            cr0, 0, r5, 8			! are there 8 or more bytes left?
      blt             cr0, .L.__residue_TROT		! false, goto residue
      andi.           r6, r3, 0xf                       ! check if input is aligned at 16 bytes.
      beq             cr0, .L.__main_TROT
.L.__dotest8_TROT:
	 lwz			 r6, 0(r3)
	 and.		     tempReg1, r6, tempReg5
     bne             cr0, .L.__residue_TROT

	 lwz			 tempReg2, 4(r3)
	 and.		     tempReg1, tempReg2, tempReg5
     bne             cr0, .L.__residue_TROT

         rlwinm                  tempReg1, r6, 0, 16, 31
	 srwi			 r6, r6, 16

         rlwinm                  tempReg3, tempReg2, 0, 16, 31
	 srwi			 tempReg2, tempReg2, 16
      insrwi          r6,       r6, 16, 8
      insrwi          tempReg1, tempReg1, 16, 8
      insrwi          tempReg2, tempReg2, 16, 8
      insrwi          tempReg3, tempReg3, 16, 8
      and             r6, r6, tempReg4
      and             tempReg1, tempReg1, tempReg4
      and             tempReg2, tempReg2, tempReg4
      and             tempReg3, tempReg3, tempReg4
      stw             r6, 0(r4)
      stw             tempReg1, 4(r4)
      stw             tempReg2, 8(r4)
      stw             tempReg3, 12(r4)

      addi            r3, r3, 8
      addi            r4, r4, 16
      addi            r5, r5, -8
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT

.L.__main_TROT:
	cmpi			cr0, 0, r5, 16					! are there 16 or more bytes left?
	blt             cr0, .L.__residue_TROT			! false, goto residue

	rlwinm          r6, r5, 32-4, 4, 31             ! r6 = num_elements / 16, processed in vector loop
	mtctr           r6
	rlwinm          r5, r5, 0, 28, 31               ! r5 = num_elements % 16, processed in residue loop

    vspltisb        vr4, 8                          ! vr4 = 16*{8}
    vspltisb        vr0, 4                          ! vr0 = 16*{4}
    vslb			vr4, vr4, vr0					! vr4 = 16*{0x80}

	vandc vr0, vr0, vr0								! vr0 = 0x00000000000000000000000000000000
	li r7, 0
	lvsr vr1, 0, r7									! vr1 = 0x101112131415161718191a1b1c1d1e1f
	vmrghb vr3, vr0, vr1							! vr3 = 0x00100011001200130014001500160017

	li  r7, 8
	li  r8, 16
	li  r9, 24

.L.__vectorLoop_TROT:
	lfd				fp0, 0(r3)						! load elements 0-7
	lfd				fp1, 8(r3)						! load elements 8-15
	xxlor			vs33, vs0, vs0					! move over to VMX registers.
	xxlor			vs34, vs1, vs1

	vmrghb			vr5, vr1, vr2					! merge bytes in high doublewords of vr1 and vr2 into vr5
	vand			vr5, vr5, vr4					! mask all bytes with 0x80
	vcmpequh_r  vr5, vr5, vr0
	bge-            cr6, .L.__loop_abort_TROT       ! if !cr[lt], i.e. ge, at least one element has bits in 0x80 goto residue

	vperm			vr1, vr0, vr1, vr3				! unpack high 8 bytes into 16 bytes.
	vperm			vr2, vr0, vr2, vr3				! unpack  low 8 bytes into 16 bytes.

	#ifdef VSXSTORES
		xxlor			vs0, vs33, vs33					! move to fp0
		xxpermdi		vs1, vs33, vs33, 2				! swap elements 0-7 with 8-15, move to fp1b
		xxlor			vs2, vs34, vs34					! move to fp2
		xxpermdi		vs3, vs34, vs34, 2				! swap elements 16-23 with 24-31, move to fp3

		stfdx           fp0,  0, r4                     ! store elements 0-7
	    stfdx           fp1, r7, r4                     ! store elements 8-15
		stfdx           fp2, r8, r4                     ! store elements 16-23
	    stfdx           fp3, r9, r4                     ! store elements 24-31
	#else
	    xxlor           vs0, vs33, vs33                 ! move to fp0
	    xxpermdi        vs1, vs33, vs33, 2              ! swap elements 0-7 with 8-15, move to fp1
	    xxlor           vs2, vs34, vs34                 ! move to fp2
	    xxpermdi        vs3, vs34, vs34, 2              ! swap elements 0-7 with 8-15, move to fp3

		stfdx           fp0,  0, r4                     ! store elements 0-7
	    stfdx           fp1, r7, r4                     ! store elements 8-15
		stfdx           fp2, r8, r4                     ! store elements 16-23
	    stfdx           fp3, r9, r4                     ! store elements 24-31
	#endif
    addi            r3, r3, 16                      ! bump input ptr
    addi            r4, r4, 32                      ! bump output ptr
    bdnz            .L.__vectorLoop_TROT

.L.__loop_abort_TROT:
        mfctr   r6                                !Get number of iterations left back.
        rlwimi  r5, r6, 4, 0, 31-4                ! r5 = r6 * 16 + r5, add remaining elements from vector loop and remainder back.
.L.__simple_TROT:
        cmpi    cr0, 0, r5, 0
        beq     cr0, .L.__done_TROT               ! if 0 elements left, we are done
.L.__residue_TROT:
		lbz             r6, 0(r3)
		andi.           r7, r6, 0x80
                bne             cr0, .L.__done_TROT
		sth             r6, 0(r4)
		addi            r3, r3, 1
		addi            r4, r4, 2
		addi            r5, r5, -1
		cmpi            cr0, 0, r5, 0
                bne             cr0, .L.__residue_TROT

.L.__done_TROT:
        laddr           r6, -ALen(J9SP)
        subf            r3, r6, r3                      ! r3 = output_ptr - output_base_ptr = num_elements_processed
        blr

#ifdef AIXPPC
        .machine "pop"
#endif
    	endproc.__arrayTranslateTROT:
#else
    	startproc.__arrayTranslateTROT:

        staddr          r3, -ALen(J9SP)                ! preserve start of output buffer for later

        cmpi            cr0, 0, r5, 16
        blt             cr0, .L.__simple_TROT

      	lis		tempReg4, 0x00ff
      	lis	        tempReg5, 0x8080
      	ori	        tempReg4, tempReg4, 0x00ff
      	ori	        tempReg5, tempReg5, 0x8080

      andi.           r6, r3, 0xf                       ! if set, input alignment is at 8 bytes.
      beq             cr0, .L.__main_TROT

      !Not 16 byte aligned
      !This is both entry and exit alignment/residue code.
.L.__test1_TROT:
      cmpi            cr0, 0, r5, 1			! are there 1 or more bytes left?
      blt             cr0, .L.__done_TROT		! false, done
      andi.           r6, r3, 0x1                       ! if set, input is aligned at an odd byte.
      beq	      cr0, .L.__test2_TROT
.L.__dotest1_TROT:
      lbz             r6, 0(r3)
      and.			  tempReg1, r6, tempReg5
      bne             cr0, .L.__done_TROT		!Skip going to residue, no point
      sth             r6, 0(r4)
      addi            r3, r3, 1
      addi            r4, r4, 2
      addi            r5, r5, -1
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT
.L.__test2_TROT:					! aligned at 2 bytes.
      cmpi            cr0, 0, r5, 2			! are there 2 or more bytes left?
      blt             cr0, .L.__residue_TROT		! false, goto residue
      andi.           r6, r3, 0x3                       ! check if input is aligned at 4 bytes.
      beq             cr0, .L.__test4_TROT
.L.__dotest2_TROT:
      lhz             r6, 0(r3)                         ! Suppose R6 = 0x0000cafe
      and.			  tempReg1, r6, tempReg5
      bne             cr0, .L.__residue_TROT
      insrwi          r6, r6, 16, 8                     ! get R6 = 0x00cafefe
      and             r6, r6, tempReg4                  ! get R6 = 0x00cafefe & 0x00ff00ff = 0x00ca00fe
      stw             r6, 0(r4)
      addi            r3, r3, 2
      addi            r4, r4, 4
      addi            r5, r5, -2
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT
.L.__test4_TROT:
      cmpi            cr0, 0, r5, 4			! are there 4 or more bytes left?
      blt             cr0, .L.__residue_TROT	        ! false, goto residue
      andi.           r6, r3, 0x7                       ! check if input is aligned at 8 bytes.
      beq             cr0, .L.__test8_TROT
.L.__dotest4_TROT:
      lhz             r6, 0(r3)                         ! suppose R6 = 0xcafe
      and.			  tempReg1, r6, tempReg5
      bne             cr0, .L.__residue_TROT
      lhz             tempReg1, 2(r3)                   ! get tempReg1 = 0xbabe rest is same as above.
      and.			  tempReg2, tempReg1, tempReg5
      bne             cr0, .L.__residue_TROT
      insrwi          r6, r6, 16, 8
      insrwi          tempReg1, tempReg1, 16, 8
      and             r6, r6, tempReg4
      and             tempReg1, tempReg1, tempReg4
      stw             r6, 0(r4)
      stw             tempReg1, 4(r4)
      addi            r3, r3, 4
      addi            r4, r4, 8
      addi            r5, r5, -4
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT
.L.__test8_TROT:
      cmpi            cr0, 0, r5, 8			! are there 8 or more bytes left?
      blt             cr0, .L.__residue_TROT		! false, goto residue
      andi.           r6, r3, 0xf                       ! check if input is aligned at 16 bytes.
      beq             cr0, .L.__main_TROT
.L.__dotest8_TROT:
	 lwz			 r6, 0(r3)
	 and.		     tempReg1, r6, tempReg5
     bne             cr0, .L.__residue_TROT

	 lwz			 tempReg2, 4(r3)
	 and.		     tempReg1, tempReg2, tempReg5
     bne             cr0, .L.__residue_TROT

         rlwinm                  tempReg1, r6, 0, 16, 31
	 srwi			 r6, r6, 16

         rlwinm                  tempReg3, tempReg2, 0, 16, 31
	 srwi			 tempReg2, tempReg2, 16

      insrwi          r6,       r6, 16, 8
      insrwi          tempReg1, tempReg1, 16, 8
      insrwi          tempReg2, tempReg2, 16, 8
      insrwi          tempReg3, tempReg3, 16, 8
      and             r6, r6, tempReg4
      and             tempReg1, tempReg1, tempReg4
      and             tempReg2, tempReg2, tempReg4
      and             tempReg3, tempReg3, tempReg4
      stw             tempReg1, 0(r4)
      stw             r6, 4(r4)

      stw             tempReg3, 8(r4)
      stw             tempReg2, 12(r4)

      addi            r3, r3, 8
      addi            r4, r4, 16
      addi            r5, r5, -8
      cmpi            cr0, 0, r5, 0
      beq             cr0, .L.__done_TROT

.L.__main_TROT:
	cmpi			cr0, 0, r5, 16					! are there 16 or more bytes left?
	blt             cr0, .L.__residue_TROT			! false, goto residue

	rlwinm          r6, r5, 32-4, 4, 31             ! r6 = num_elements / 16, processed in vector loop
	mtctr           r6
	rlwinm          r5, r5, 0, 28, 31               ! r5 = num_elements % 16, processed in residue loop

    vspltisb        vr4, 8                          ! vr4 = 16*{8}
    vspltisb        vr0, 4                          ! vr0 = 16*{4}
    vslb			vr4, vr4, vr0					! vr4 = 16*{0x80}

	vandc vr0, vr0, vr0								! vr0 = 0x00000000000000000000000000000000

	li  r6, 16
    vspltisw        vr3, 0x10            ! vr3 = 4*{-16} - this is used to shift by 16 bits later

.L.__vectorLoop_TROT:
    lxvw4x          vs33, r0, r3

	vand			vr2, vr1, vr4					! mask all bytes with 0x80
	vcmpequh_r  vr2, vr2, vr0
	bge-            cr6, .L.__loop_abort_TROT       ! if !cr[lt], i.e. ge, at least one element has bits in 0x80 goto residue

    vrlw            vr1, vr1, vr3                   ! fix byte ordering for a little endian load
    vmrghb          vr2, vr0, vr1
    vmrglb          vr1, vr0, vr1
    stxvw4x         vs34, r0, r4                     ! store elements 0-7
    stxvw4x         vs33, r4, r6                    ! store elements 8-15

    addi            r3, r3, 16                      ! bump input ptr
    addi            r4, r4, 32                      ! bump output ptr
    bdnz            .L.__vectorLoop_TROT

.L.__loop_abort_TROT:
        mfctr   r6                                !Get number of iterations left back.
        rlwimi  r5, r6, 4, 0, 31-4                ! r5 = r6 * 16 + r5, add remaining elements from vector loop and remainder back.
.L.__simple_TROT:
        cmpi    cr0, 0, r5, 0
        beq     cr0, .L.__done_TROT               ! if 0 elements left, we are done
.L.__residue_TROT:
		lbz             r6, 0(r3)
		andi.		r7, r6, 0x80
                bne             cr0, .L.__done_TROT
		sth             r6, 0(r4)
		addi            r3, r3, 1
		addi            r4, r4, 2
		addi            r5, r5, -1
		cmpi            cr0, 0, r5, 0
                bne             cr0, .L.__residue_TROT

.L.__done_TROT:
        laddr           r6, -ALen(J9SP)
        subf            r3, r6, r3                      ! r3 = output_ptr - output_base_ptr = num_elements_processed
        blr

#ifdef AIXPPC
        .machine "pop"
#endif
    	endproc.__arrayTranslateTROT:
#endif


#if 0
!----------------------------------------------------------------------
! entry arrayTranslateTRTOSimpleVMX
!----------------------------------------------------------------------
! To minimize conditional branches due to various configuration,
! e.g. data alignment and data size, we employed a decision table through
! which one of the 64 hanlders is selected with 6-bit vector as described
! below.
!
! How to compute parameters:
!   headerCount = (-outp) & 15;
!   block4Count = (len - headerCount) / 16 / 4;
!   blockCount = ((len - headerCount) / 16) & 3;
!   trailerCount = (outp + len) & 15;
!
!   swSlowPath = (outp & ~15) == ((outp + len) & ~15);
!   swSrcDstAlign = (((inp >> 1) XOR outp) & 7) == 0; Src and dst are mutually aligned
!   swHeader = headerCount != 0;
!   swBlock4Loop = block4Count != 0;
!   swTrailer = trailerCount != 0;
!
!   vector = (swSlowPath << 6) |
!	     (swSrcDstAlign << 5) |
!	     (swHeader << 4) |
!            (swBlock4Loop << 3) |
!            (blockCount & 3) << 1 |
!	     swTrailer
!
!       +-------------------------------------------- swSlowPath
!       |   +---------------------------------------- swSrcDstAlign
!       |   |   +------------------------------------ swHeader
!       |   |   |   +-------------------------------- swBlock4Loop
!       |   |   |   |   +---------------------------- blockCount    0..3
!       |   |   |   |   |       +-------------------- swTrailer
!       |   |   |   |   |       |   +---------------- Partial header block
!       |   |   |   |   |       |   |   +------------ 4x unrolled blocks
!       |   |   |   |   |       |   |   |     +------ A pair of block
!       |   |   |   |   |       |   |   |     |  +--- Single block
!       |   |   |   |   |       |   |   |     |  | +- Partial trailer block
!       |   |   |   |   |       |   |   |     |  | |
!       V   V   V   V   V       V   V   V     V  V V
!       -   -   -   -   -----   -   --- ----- -- - ---
! -----+---------------------------+------------------+-------------+
!      |       Configuration       |   Patte n        |Handler      |
! -----+---------------------------+------------------+-------------+
!      |0   0   0   0   0   0   0  |                  |invalid      |
!      |0   0   0   0   0   0   1  |                  |invalid      |
!      |0   0   0   0   0   1   0  |             B    |vector000010 |
!      |0   0   0   0   0   1   1  |             B PP.|vector000011 |
!      |0   0   0   0   1   0   0  |          BB      |vector000100 |
!      |0   0   0   0   1   0   1  |          BB   PP.|vector000101 |
!      |0   0   0   0   1   1   0  |          BB B    |vector000110 |
!      |0   0   0   0   1   1   1  |          BB B PP.|vector000111 |
!      |0   0   0   1   0   0   0  |    BBBB+         |vector001000 |
!      |0   0   0   1   0   0   1  |    BBBB+      PP.|vector001001 |
!      |0   0   0   1   0   1   0  |    BBBB+    B    |vector001010 |
!      |0   0   0   1   0   1   1  |    BBBB+    B PP.|vector001011 |
!      |0   0   0   1   1   0   0  |    BBBB+ BB      |vector001100 |
!      |0   0   0   1   1   0   1  |    BBBB+ BB   PP.|vector001101 |
!      |0   0   0   1   1   1   0  |    BBBB+ BB B    |vector001110 |
!      |0   0   0   1   1   1   1  |    BBBB+ BB B PP.|vector001111 |
!      |0   0   1   0   0   0   0  |.PP               |vector010000 |
!      |0   0   1   0   0   0   1  |.PP            PP.|vector010001 |
!      |0   0   1   0   0   1   0  |.PP          B    |vector010010 |
!      |0   0   1   0   0   1   1  |.PP          B PP.|vector010011 | <-- NG case 20060627
!      |0   0   1   0   1   0   0  |.PP       BB      |vector010100 |
!      |0   0   1   0   1   0   1  |.PP       BB   PP.|vector010101 |
!      |0   0   1   0   1   1   0  |.PP       BB B    |vector010110 |
!      |0   0   1   0   1   1   1  |.PP       BB B PP.|vector010111 |
!      |0   0   1   1   0   0   0  |.PP BBBB+         |vector011000 |
!      |0   0   1   1   0   0   1  |.PP BBBB+      PP.|vector011001 |
!      |0   0   1   1   0   1   0  |.PP BBBB+    B    |vector011010 |
!      |0   0   1   1   0   1   1  |.PP BBBB+    B PP.|vector011011 |
!      |0   0   1   1   1   0   0  |.PP BBBB+ BB      |vector011100 |
!      |0   0   1   1   1   0   1  |.PP BBBB+ BB   PP.|vector011101 |
!      |0   0   1   1   1   1   0  |.PP BBBB+ BB B    |vector011110 |
!      |0   0   1   1   1   1   1  |.PP BBBB+ BB B PP.|vector011111 |

!      |0   1   0   0   0   0   0  |                  |invalid      |
!      |0   1   0   0   0   0   1  |                  |invalid      |
!      |0   1   0   0   0   1   0  |             B    |vector100010 |
!      |0   1   0   0   0   1   1  |             B PP.|vector100011 |
!      |0   1   0   0   1   0   0  |          BB      |vector100100 |
!      |0   1   0   0   1   0   1  |          BB   PP.|vector100101 |
!      |0   1   0   0   1   1   0  |          BB B    |vector100110 |
!      |0   1   0   0   1   1   1  |          BB B PP.|vector100111 |
!      |0   1   0   1   0   0   0  |    BBBB+         |vector101000 |
!      |0   1   0   1   0   0   1  |    BBBB+      PP.|vector101001 |
!      |0   1   0   1   0   1   0  |    BBBB+    B    |vector101010 |
!      |0   1   0   1   0   1   1  |    BBBB+    B PP.|vector101011 |
!      |0   1   0   1   1   0   0  |    BBBB+ BB      |vector101100 |
!      |0   1   0   1   1   0   1  |    BBBB+ BB   PP.|vector101101 |
!      |0   1   0   1   1   1   0  |    BBBB+ BB B    |vector101110 |
!      |0   1   0   1   1   1   1  |    BBBB+ BB B PP.|vector101111 |
!      |0   1   1   0   0   0   0  |.PP               |vector110000 |
!      |0   1   1   0   0   0   1  |.PP            PP.|vector110001 |
!      |0   1   1   0   0   1   0  |.PP          B    |vector110010 |
!      |0   1   1   0   0   1   1  |.PP          B PP.|vector110011 |
!      |0   1   1   0   1   0   0  |.PP       BB      |vector110100 |
!      |0   1   1   0   1   0   1  |.PP       BB   PP.|vector110101 |
!      |0   1   1   0   1   1   0  |.PP       BB B    |vector110110 |
!      |0   1   1   0   1   1   1  |.PP       BB B PP.|vector110111 |
!      |0   1   1   1   0   0   0  |.PP BBBB+         |vector111000 |
!      |0   1   1   1   0   0   1  |.PP BBBB+      PP.|vector111001 |
!      |0   1   1   1   0   1   0  |.PP BBBB+    B    |vector111010 |
!      |0   1   1   1   0   1   1  |.PP BBBB+    B PP.|vector111011 |
!      |0   1   1   1   1   0   0  |.PP BBBB+ BB      |vector111100 |
!      |0   1   1   1   1   0   1  |.PP BBBB+ BB   PP.|vector111101 |
!      |0   1   1   1   1   1   0  |.PP BBBB+ BB B    |vector111110 |
!      |0   1   1   1   1   1   1  |.PP BBBB+ BB B PP.|vector111111 |

!      |1   0   0   0   0   0   0  ||..               |null         | Length zero, aligned
!      |1   0   0   0   0   0   1  |               PP.|vector000001 |
!      |1   0   0   0   0   1   0  |                  |invalid      |
!      |1   0   0   0   0   1   1  |                  |invalid      |
!      |1   0   0   0   1   0   0  |                  |invalid      |
!      |1   0   0   0   1   0   1  |                  |invalid      |
!      |1   0   0   0   1   1   0  |                  |invalid      |
!      |1   0   0   0   1   1   1  |                  |invalid      |
!      |1   0   0   1   0   0   0  |                  |invalid      |
!      |1   0   0   1   0   0   1  |                  |invalid      |
!      |1   0   0   1   0   1   0  |                  |invalid      |
!      |1   0   0   1   0   1   1  |                  |invalid      |
!      |1   0   0   1   1   0   0  |                  |invalid      |
!      |1   0   0   1   1   0   1  |                  |invalid      |
!      |1   0   0   1   1   1   0  |                  |invalid      |
!      |1   0   0   1   1   1   1  |                  |invalid      |
!      |1   0   1   0   0   0   0  |                  |invalid      |
!      |1   0   1   0   0   0   1  |                  |invalid      |
!      |1   0   1   0   0   1   0  |                  |invalid      |
!      |1   0   1   0   0   1   1  |.P.       .. B .P.|invalid      |
!      |1   0   1   0   1   0   0  |          BB .    |invalid      |
!      |1   0   1   0   1   0   1  |.P.       BB . .P.|invalid      |
!      |1   0   1   0   1   1   0  |          BB B    |invalid      |
!      |1   0   1   0   1   1   1  |.P.       BB B .P.|invalid      |
!      |1   0   1   1   0   0   0  |          .. .    |invalid      |
!      |1   0   1   1   0   0   1  |.P.       .. . .P.|invalid      |
!      |1   0   1   1   0   1   0  |          .. B    |invalid      |
!      |1   0   1   1   0   1   1  |.P.       .. B .P.|invalid      |
!      |1   0   1   1   1   0   0  |          BB .    |invalid      |
!      |1   0   1   1   1   0   1  |.P.       BB . .P.|invalid      |
!      |1   0   1   1   1   1   0  |          BB B    |invalid      |
!      |1   0   1   1   1   1   1  |.P.       BB B .P.|partialVector| Also includes length zero, unaligned cases.

!      |1   1   0   0   0   0   0  ||..               |null         | Length zero, aligned
!      |1   1   0   0   0   0   1  |               PP.|vector100001 |
!      |1   1   0   0   0   1   0  |                  |invalid      |
!      |1   1   0   0   0   1   1  |                  |invalid      |
!      |1   1   0   0   1   0   0  |                  |invalid      |
!      |1   1   0   0   1   0   1  |                  |invalid      |
!      |1   1   0   0   1   1   0  |                  |invalid      |
!      |1   1   0   0   1   1   1  |                  |invalid      |
!      |1   1   0   1   0   0   0  |                  |invalid      |
!      |1   1   0   1   0   0   1  |                  |invalid      |
!      |1   1   0   1   0   1   0  |                  |invalid      |
!      |1   1   0   1   0   1   1  |                  |invalid      |
!      |1   1   0   1   1   0   0  |                  |invalid      |
!      |1   1   0   1   1   0   1  |                  |invalid      |
!      |1   1   0   1   1   1   0  |                  |invalid      |
!      |1   1   0   1   1   1   1  |                  |invalid      |
!      |1   1   1   0   0   0   0  |                  |invalid      |
!      |1   1   1   0   0   0   1  |                  |invalid      |
!      |1   1   1   0   0   1   0  |                  |invalid      |
!      |1   1   1   0   0   1   1  |.P.       .. B .P.|invalid      |
!      |1   1   1   0   1   0   0  |          BB .    |invalid      |
!      |1   1   1   0   1   0   1  |.P.       BB . .P.|invalid      |
!      |1   1   1   0   1   1   0  |          BB B    |invalid      |
!      |1   1   1   0   1   1   1  |.P.       BB B .P.|invalid      |
!      |1   1   1   1   0   0   0  |          .. .    |invalid      |
!      |1   1   1   1   0   0   1  |.P.       .. . .P.|invalid      |
!      |1   1   1   1   0   1   0  |          .. B    |invalid      |
!      |1   1   1   1   0   1   1  |.P.       .. B .P.|invalid      |
!      |1   1   1   1   1   0   0  |          BB .    |invalid      |
!      |1   1   1   1   1   0   1  |.P.       BB . .P.|invalid      |
!      |1   1   1   1   1   1   0  |          BB B    |invalid      |
!      |1   1   1   1   1   1   1  |.P.       BB B .P.|partialVector| Also includes length zero, unaligned cases.
! -----+---------------------------+------------------+-------------+
!
! Legends:
!      ...   No data
!      .PP   Partial block (missing a part at head)
!      .P.   Partial block (imssing a part at both head and tail)
!      PP.   Partial block (missing a part at tail)
!      BBBB+ One or more 4x unrolled blocks
!      BB    A pair of blocks
!      B     Single block
!      |..   Zero length block at block boundary
!      .|.   Zero length block at middle of boundary
!      ..|   Zero length block just before block boundary

#ifdef AIXPPC
.__arrayTranslateTRTOSimpleVMX:
	.function .__arrayTranslateTRTOSimpleVMX,startproc.__arrayTranslateTRTOSimpleVMX,16,0,(endproc.__arrayTranslateTRTOSimpleVMX-startproc.__arrayTranslateTRTOSimpleVMX)
#elif defined(LINUXPPC64)
FUNC_LABEL(__arrayTranslateTRTOSimpleVMX):
#else
__arrayTranslateTRTOSimpleVMX:
#endif
    	startproc.__arrayTranslateTRTOSimpleVMX:
	!-------------------------------------------------------------------
	!   Reg.        Input           Output          Use
	!-------------------------------------------------------------------
	!   r0                          DESTROYED
	!   r3                          <num. char. transformed> - 1
	!   r4          inp             DESTROYED
	!   r5          outp            DESTROYED
	!   r6          len             len
	!   r7          maxChar         maxChar
	!   r8     	vmaxCharsMem    DESTROYED
	!   r9                          DESTROYED
	!   r10                         DESTROYED
	!   r11                         DESTROYED
	!   r12                         DESTROYED
	!
	!   ctr                         DESTROYED
	!   cr0                         DESTROYED
	!   cr6                         DESTROYED
	!
	!   vr0                         DESTROYED
	!   vr1                         DESTROYED
	!   vr2                         DESTROYED
	!   vr3                         DESTROYED
	!   vr4                         DESTROYED
	!   vr5                         DESTROYED
	!   vr6                         DESTROYED
	!   vr7                         DESTROYED
	!   vr8                         DESTROYED
	!   vr9                         DESTROYED
	!   vr10                        DESTROYED
	!   vr11                        DESTROYED
	mtctr	r7			! Spill maxChar into CTR
	lvx 	vr0, r0, r8		! vmaxChars = *vmaxCharsMem
	add	r8,r5,r6		! r8 = outp + len
	neg	r11,r5			! r11 = -outp
	rlwinm	r0,r8,0,0,27		! r0 = (outp + len) & ~15
	rlwinm	r9,r5,0,0,27		! r9 = outp & ~15
	rlwinm	r10,r11,0,28,31		! r10 = (-out) & 15				headerCount
	xor	r3,r9,r0		! r3 = (outp & ~15) XOR ((outp + len) & ~15)
	subfic	r11,r3,0		! r11/CA = 0 - r3  (Set carry if r3 is zero)
	adde	r3,r11,r3		! r3 = (outp & ~15) == ((outp + len) & ~15)	swSlowPath
	subf	r12,r10,r6		! r12 = len - headerCount
	rlwinm	r0,r12,29,29,30		! r0 = (((len - headerCount) / 16) & 3) << 1	blockCount << 1
	srwi	r11,r12,6		! r11 = (len - headerCount) / 16		block4Count
	neg	r7,r10			! r7 = -headerCount
	slwi	r12,r3,6		! r12 = (swSlowPath << 6)
	srwi	r3,r4,1			! inp >> 1
	xor	r3,r3,r5		! (inp >> 1) & outp
	andi.	r3,r3,7			! ((inp >> 1) XOR outp) & 7
	mfcr	r3			! CR0_EQ = (((inp >> 1) XOR outp) & 7) == 0
	rlwinm	r3,r3,8,26,26
	or	r12,r12,r3		! r12 = (swSlowPath << 6) | (swSrcDstAlign << 5)
	rlwinm	r3,r7,5,27,27		! r3 = (headerCount != 0) << 4			swHeader << 4
	or	r9,r12,r0		! r9 = (swSlowPath << 6) | (blockCount << 1)
	rlwinm	r12,r8,0,28,31		! r12 = (outp + len) & 15			trailerCount
	neg	r8,r11			! r8 = -blockCount
	or	r3,r9,r3		! r3 = (swSlowPath << 6) | (swHeader << 4) | (blockCount << 1)
	rlwinm	r0,r8,4,28,28		! r0 = (blockCount != 0) << 3			swBlock4Loop << 3
	neg	r7,r12			! r7 = -trailerCount
	or	r8,r3,r0	    	! r8 = (swSlowPath << 6) | (swHeader << 4) | (swBlock4Loop << 3) | (blockCount << 1)
	rlwinm	r9,r7,1,31,31		! r0 = (traileCount != 0) << 0			swTrailer << 0
	or	r0,r8,r9	    	! r0 = (swSlowPath << 6) | (swHeader << 4) | (swBlock4Loop << 3) | (blockCount << 1) | (swTrailer << 0)
	mfctr	r7			! Restore maxChar

	! Look up a function pointer from dispatch table CTR <- func[r0]
	laddr	r3, J9TR_VMThreadRTOCOffset(J9VM_STRUCT)	! Restore TOC/GOT
#ifdef TR_HOST_64BIT
	rlwinm	r0, r0, 3, 0xFFFFFFF8
#else
	rlwinm	r0, r0, 2, 0xFFFFFFFC
#endif
#ifdef AIXPPC
	laddr	r3, TOC__arrayTranslateLabelTable(r3)
#elif defined(LINUXPPC64)
	laddr	r3, TOC__arrayTranslateLabelTable@toc(r3)
#else
	laddr	r3, __arrayTranslateLabelTable@got(r3)
#endif
	laddrx	r3, r3, r0
	mtctr	r3
	! Do rest of initialization
    	li 	r3, 0			! index = 0
	li 	r8, 16			! const16 = 16
	li 	r9, 32			! const32 = 32
	li 	r0, 48			! const48 = 48
	!-------------------------------
    	! Exit condition
	!   reg		content
	!-------------------------------
	!   r0  -- 	const48
	!   r3  -- 	index
	!   r4  -- 	inp
	!   r5  -- 	outp
	!   r6  -- 	len
	!   r7  -- 	maxChar
	!   r8  -- 	const16
	!   r9  -- 	const32
	!   r10 -- 	headerCount
	!   r11 --	blockCount
	!   r12 --	trailerCount
	!   vr0 --	vmaxChars
	!-------------------------------
	bctr
!----------------------------------------------------------------------
! end of arrayTranslateTRTOSimpleVMX
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! macro definitions
!    macroArrayTranslate swHeader,swSrcDstAlign,swBlock4Loop,swBlock2,swBlock1,swTrailer
!      macroArrayTranslateHeader
!      macroArrayTranslateUnrollInit
!      macroArrayTranslateUnrolledBodyN swSrcDstAlign num
!        macroArrayTranslateUnrolledBodyGen vin0 vin2 swSrcDstAlign outReg firstBlock
!      macroArrayTranslateTrailer
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! macro macroArrayTranslateHeader
!----------------------------------------------------------------------
	! Header processing (paritial block with missing part at start)
	!
	!   Reg.        Input           Output          Use
	!-------------------------------------------------------------------
	!   r0          const48         const48
	!   r3          index           index+headerCount
	!   r4          inp             inp+headerCount*2
	!   r5          outp            outp+headerCount
	!   r6          (len)           len
	!   r7          (maxChar)       maxChar
	!   r8          const16         const16
	!   r9          const32         const32
	!   r10         headerCount     headerCount
	!   r11         (blockCount)    blockCount
	!   r12         (trailerCount)  trailerCount
	!
	!   vr0         vmaxChars       vmaxChars
	!   vr1                         DESTROYED       vpat vopat
	!   vr2                         DESTROYED       vin0 vcmp0 vcmp01 vcmp01_masked dummy
	!   vr3                         DESTROYED       vin1 vcmp1 vomask
	!   vr4                         DESTROYED       vin2 vorig
	!   vr5                         DESTROYED       v0 vout/vout_shift/vout_sel
	!   vr6                         DESTROYED       v1 vconst_0x0f
	!
	! Exceptional case: Exit to L.doScalar
	!   r3     cur. index
	!   r4     cur. inp
	!   r5     our. outp
	!   r6     len
	!   r7     maxChar
	!.macro macroArrayTranslateHeader
define(`macroArrayTranslateHeader', ` \
! macrocall: `$0'() \
	lvsl 	vr1, r0, r4		! vpat = lvsl(0, inp) \
	lvx 	vr2, r0, r4		! vin0 = *(vector *)inp \
	lvx 	vr3, r8, r4		! vin1 = *((vector *)inp + 1) \
	lvx 	vr4, r9, r4		! vin2 = *((vector *)inp + 2) \
	vperm 	vr5, vr2, vr3, vr1	! v0 = perm(vin0, vin1, vpat) \
	vperm 	vr6, vr3, vr4, vr1  	! v1 = perm(vin1, vin2, vpat) \
	vcmpgtuh vr2, vr5, vr0		! vcmp0 = vec_cmpgt(v0, vmaxChars) \
	vcmpgtuh vr3, vr6, vr0		! vcmp1 = vec_cmpgt(v1, vmaxChars) \
	vpkuhum vr2,vr2,vr3		! vcmp01 = vec_pack(vcmp0, vcmp1)   ! left adjusted packed comp. result \
	lvsr	vr1, r0, r5		! vopat = lvsr(0, output)  \
	vperm	vr2, vr2, vr2, vr1	! vcomp01 = vec_perm(vcmp01, vcmp01, vopat) Adjust packed compare result \
	vpkuhum	vr5, vr5, vr6		! vout = pack(v0, v1)		    ! left adjusted packed result \
	vspltisb vr6, 15		! vconst_0x0f = vec_splat_u8(15) \
	vcmpgtub vr3, vr1, vr6		! vomask = vec_cmpgt(vopat, vconst_0x0f) (output&15)"00" . (16-(output&15))"ff" \
	vand    vr2, vr2, vr3		! vcmp01_masked = vec_and(vcmp01, vomask) \
	vcmpgtub.   vr2,vr2,vr6         ! if (vec_any_gt(vcmp01_masked,vconst_0x0f))... \
	bc 	BO_IF_NOT_2, CR6_EQ, L.doScalar	! Yes, do scalar processing (statically predicted as unlikely) \
	vperm	vr5, vr5, vr5, vr1	! vout = vec_perm(vout, vout, vopat). Adjust packed result \
	lvx	vr4, r0, r5		! vorig = vec_ld(0, outp) \
	vsel	vr5, vr4, vr5, vr3	! vout = vec_sel(vorig, vout, vomask) \
	add 	r3, r3, r10		! index += headerCount	    SCHED:Can be moved anywhere in this macro \
	add 	r4, r4, r10		! inp += 2 * headerCount    SCHED:anywhere after the 3rd lvx \
	add 	r4, r4, r10		! \
	stvx 	vr5, r0, r5		! *outp = vout \
	add 	r5, r5, r10		! outp += headerCount \
)
!----------------------------------------------------------------------
! end of macro macroArrayTranslateHeader
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! macro macroArrayTranslateUnrollInit
!----------------------------------------------------------------------
	! Loop of 4-times unrolled block
	!
	!   Reg.        Input           Output          Use
	!-------------------------------------------------------------------
	!   r0          const48         const48
	!   r3          index           index+16*N
	!   r4          inp             inp+32*N
	!   r5          outp (aligned)  outp+16*N
	!   r6          (len)           len
	!   r7          (maxChar)       maxChar
	!   r8          const16         const16
	!   r9          const32         const32
	!   r10         (headerCount)   headerCount <- can be destroyed
	!   r11         block4Count     block4Count
	!   r12         (trailerCount)  trailerCount
	!
	!   vr0         vmaxChars       vmaxChars
	!   vr1                         DESTROYED       vpat
	!   vr2                         DESTROYED       vin0
	!   vr3                         DESTROYED       vin1
	!   vr4                         DESTROYED       vin2
	!   vr5                         DESTROYED       v0
	!   vr6                         DESTROYED       v1
	!   vr7                         DESTROYED       dummy
	!   vr8                         DESTROYED       vout0
	!   vr9                         DESTROYED       vout1
	!   vr10                        DESTROYED       vout2
	!   vr11                        DESTROYED       vout3
	!
	! Exceptional case: Exit to L.doScalar
	!   r3     cur. index
	!   r4     cur. inp
	!   r5     our. outp
	!   r6     len
	!   r7     maxChar
!.macro macroArrayTranslateUnrollInit swSrcDstAlign
define(`macroArrayTranslateUnrollInit', ` \
! macrocall: `$0'(`$1') \
ifelse($1, `0', ` \
	lvsl 	vr1, r0, r4		! vpat = lvsl(0, inp) \
	lvx 	vr2, r0, r4		! vin0 = *(vector *)inp \
') \
')
!----------------------------------------------------------------------
! end of macro macroArrayTranslateUnrollInit
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! macro macroArrayTranslateUnrolledBodyGen
!----------------------------------------------------------------------
!.macro macroArrayTranslateUnrolledBodyGen vin0 vin2 swSrcDstAlign outReg firstBlock
define(`macroArrayTranslateUnrolledBodyGen', ` \
! macrocall: `$0'(`$1', `$2', `$3', `$4', `$5') \
ifelse(`$3', `1', ` \
	lvx 	vr5, r0, r4			! vin1 = *((vector *)inp + 1) \
	lvx 	vr6, r8, r4			! vin2 = *((vector *)inp + 2) \
', ` \
	lvx 	vr3, r8, r4			! vin1 = *((vector *)inp + 1) \
	vperm 	vr5, `$1', vr3, vr1		! v0 = perm(vin0, vin1, vpat) \
	lvx 	`$2', r9, r4			! vin2 = *((vector *)inp + 2) \
	vperm 	vr6, vr3, `$2', vr1		! v1 = perm(vin1, vin2, vpat) \
') \
	addi 	r4, r4, 32			! inp += 32 \
ifelse(`$5', `1', ` \
	vmaxuh	vr7, vr5, vr6			! maxSum = max(v0, v1) \
	vpkuhum	`$4', vr5, vr6			! vout0 = pack(v0, v1) \
', ` \
	vmaxuh	`$4', vr5, vr6			! max01 = max(v0, v1) \
	vmaxuh	vr7, vr7, `$4'			! maxSum = max(maxSum, max01) \
	vpkuhum	`$4', vr5, vr6			! vout0 = pack(v0, v1) \
') \
)
!----------------------------------------------------------------------
! end of macro macroArrayTranslateUnrolledBodyGen
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! macro macroArrayTranslateUnrolledBodyN
!----------------------------------------------------------------------
!.macro macroArrayTranslateUnrolledBodyN swSrcDstAlign num
define(`macroArrayTranslateUnrolledBodyN', ` \
! macrocall: `$0'(`$1', `$2') \
ifelse(`$2', `1', ` \
    	macroArrayTranslateUnrolledBodyGen(`vr2', `vr4', `$1', `vr8', `1') \
', `$2', `2', ` \
    	macroArrayTranslateUnrolledBodyGen(`vr2', `vr4', `$1', `vr8', `1') \
    	macroArrayTranslateUnrolledBodyGen(`vr4', `vr2', `$1', `vr9', `0') \
', `$2', `3', ` \
    	macroArrayTranslateUnrolledBodyGen(`vr2', `vr4', `$1', `vr8', `1') \
    	macroArrayTranslateUnrolledBodyGen(`vr4', `vr2', `$1', `vr9', `0') \
    	macroArrayTranslateUnrolledBodyGen(`vr2', `vr4', `$1', `vr10', `0') \
', `$2', `4', ` \
    	macroArrayTranslateUnrolledBodyGen(`vr2', `vr4', `$1', `vr8', `1') \
    	macroArrayTranslateUnrolledBodyGen(`vr4', `vr2', `$1', `vr9', `0') \
    	macroArrayTranslateUnrolledBodyGen(`vr2', `vr4', `$1', `vr10', `0') \
    	macroArrayTranslateUnrolledBodyGen(`vr4', `vr2', `$1', `vr11', `0') \
') \
	vcmpgtuh. vr7, vr7, vr0		! If any elem > maxChar ? \
ifelse(`$2', `1', ` \
	bc	BO_IF_NOT_2, CR6_EQ, L.doScalar1 \
', `$2', `2', ` \
	bc	BO_IF_NOT_2, CR6_EQ, L.doScalar1 \
	bc	BO_IF_NOT_2, CR6_EQ, L.doScalar2 \
', `$2', `3', ` \
	bc	BO_IF_NOT_2, CR6_EQ, L.doScalar1 \
	bc	BO_IF_NOT_2, CR6_EQ, L.doScalar2 \
	bc	BO_IF_NOT_2, CR6_EQ, L.doScalar3 \
', `$2', `4', ` \
	bc	BO_IF_NOT_2, CR6_EQ, L.doScalar1 \
	bc	BO_IF_NOT_2, CR6_EQ, L.doScalar2 \
	bc	BO_IF_NOT_2, CR6_EQ, L.doScalar3 \
	bc	BO_IF_NOT_2, CR6_EQ, L.doScalar4 \
') \
ifelse(`$2', `1', ` \
	stvx 	vr8, r0, r5		! outp[0] = vout0 \
', `$2', `2', ` \
	stvx 	vr8, r0, r5		! outp[0] = vout0 \
	stvx 	vr9, r8, r5		! outp[1] = vout1 \
', `$2', `3', ` \
	stvx 	vr8, r0, r5		! outp[0] = vout0 \
	stvx 	vr9, r8, r5		! outp[1] = vout1 \
	stvx 	vr10, r9, r5		! outp[2] = vout2 \
', `$2', `4', ` \
	stvx 	vr8, r0, r5		! outp[0] = vout0 \
	stvx 	vr9, r8, r5		! outp[1] = vout1 \
	stvx 	vr10, r9, r5		! outp[2] = vout2 \
	stvx 	vr11, r5, r0		! outp[3] = vout3  (Note: r0 must be the last parameter) \
') \
	addi 	r3, r3, 16*`$2'		! index += 16*NUM SPEC \
	addi 	r5, r5, 16*`$2'		! outp += 16*NUM SPEC \
)
!----------------------------------------------------------------------
! end of macro macroArrayTranslateUnrolledBodyN
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! macro macroArrayTranslateTrailer
!----------------------------------------------------------------------
	! Trailer processing (partial block with missing part at last)
	!
	!   Reg.        Input           Output          Use
	!-------------------------------------------------------------------
	!   r0          const48         const48
	!   r3          index           index+trailerCount
	!   r4          inp             inp (unchanged)
	!   r5          outp (aligned)  outp (unchanged)
	!   r6          len             len
	!   r7          (maxChar)       maxChar
	!   r8          const16         const16
	!   r9          const32         const32
	!   r10         (headerCount)   headerCount
	!   r11         (blockCount)    blockCount
	!   r12         trailerCount    trailerCount
	!
	!   vr0         vmaxChars       vmaxChars
	!   vr1                         DESTROYED       vpat vopat
	!   vr2                         DESTROYED       vin0 vcmp0 vcmp01 vcmp01_masked dummy
	!   vr3                         DESTROYED       vin1 vcmp1 vomask
	!   vr4                         DESTROYED       vin2 vorig
	!   vr5                         DESTROYED       v0 vout/vout_sel
	!   vr6                         DESTROYED       v1 vconst_0x0f
	!
	! Exceptional case: Exit to L.doScalar
	!   r3     cur. index
	!   r4     cur. inp
	!   r5     our. outp
	!   r6     len
	!   r7     maxChar
	! Now we are at 16-byte aligned, and have 0..15 characters to go.
!.macro macroArrayTranslateTrailer
define(`macroArrayTranslateTrailer', ` \
! macrocall: `$0'() \
	lvsl 	vr1, r0, r4		! vpat = lvsl(0, inp) \
	lvx 	vr2, r0, r4		! vin0 = *(vector *)inp \
	lvx 	vr3, r8, r4		! vin1 = *((vector *)inp + 1) \
	lvx 	vr4, r9, r4		! vin2 = *((vector *)inp + 2) \
	vperm 	vr5, vr2, vr3, vr1	! v0 = perm(vin0, vin1, vpat) \
	vperm 	vr6, vr3, vr4, vr1  	! v1 = perm(vin1, vin2, vpat) \
	vcmpgtuh vr2, vr5, vr0		! vcmp0 = vec_vcmpgt(v0, vmaxChars) \
	vcmpgtuh vr3, vr6, vr0		! vcmp1 = vec_vcmpgt(v1, vmaxChars) \
	vpkuhum  vr2,vr2,vr3		! vcmp01 = vec_pack(vcmp0, vcmp1) \
	lvsr 	vr1, r0, r12		! vopat = lvsr(0, trailerCount) \
	vpkuhum	vr5, vr5, vr6		! vout = pack(v0, v1) \
	vspltisb vr6, 15		! vconst_0x0f = vec_splat_u8(15) \
	vcmpgtub vr3, vr1, vr6		! vomask = vec_cmpgt(vopat, vconst_0x0f)   (count)"00" . (16-count)"ff" \
	vandc    vr2, vr2, vr3		! vcmp01_masked = vec_andc(vcmp01, vomask) \
	vcmpgtub.   vr2,vr2,vr6         ! if (vec_any_gt(vcmp01_masked,vconst_0x0f))... \
	bc 	BO_IF_NOT_2, CR6_EQ, L.doScalar	! Yes, do scalar processing (statically predicted as unlikely) \
	lvx	vr4, r0, r5		! vorig = vec_ld(0, outp) \
	vsel	vr5, vr5, vr4, vr3	! vout = vec_sel(vout, vorig, vomask) \
	add 	r3, r3, r12		! index += trailerCount \
	stvx 	vr5, r0, r5		! *outp = vout \
)
!----------------------------------------------------------------------
! end of macro macroArrayTranslateTrailer
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! macro macroArrayTranslate
!----------------------------------------------------------------------
define(`mkLabel', `L.$1$2$3$4$5$6$7')

!macro macroArrayTranslate swSrcDstAlign,swHeader,swBlock4Loop,swBlock2,swBlock1,swTrailer
define(`macroArrayTranslate', ` \
! macrocall: `$0'(`$1', `$2', `$3', `$4', `$5', `$6') \
	! Process partial block at beginning if any exists \
ifelse(`$2', `1', ` \
	macroArrayTranslateHeader() \
') \
	! Prepare const48, vpat, and load the first vector into vin0 \
    	macroArrayTranslateUnrollInit(`$1') \
	! Process 4x unrolled block loop if any exists \
ifelse($3, `1', ` \
	mtctr 	r11			! Number of 16-byte aligned 4*16-byte blocks. Non-zero guaranteed \
mkLabel(`$0', `$1', `$2', `$3', `$4', `$5', `$6'): \
	macroArrayTranslateUnrolledBodyN($1, 4) \
	bdnz mkLabel(`$0', `$1', `$2', `$3', `$4', `$5', `$6') \
') \
	! Process a pair of blocks if any exists. Destination is 16-byte aligned \
ifelse($4, `1', ` \
	macroArrayTranslateUnrolledBodyN($1, 2) \
') \
	! Process a full block if any exists. Destination is 16-byte aligned \
ifelse($5, `1', ` \
	macroArrayTranslateUnrolledBodyN($1, 1) \
') \
    	! Process a partial block if any exists. Destination is 16-byte aligned \
ifelse($6, `1', ` \
    	macroArrayTranslateTrailer() \
') \
	! Return to the caller \
	addi 	r3, r3, -1		! index - 1 \
	bclr	BO_ALWAYS, CR0_EQ \
) \
    	!.endm
!----------------------------------------------------------------------
! end of macro macroArrayTranslate
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! entry partialVectr010
!----------------------------------------------------------------------
	! Partial block processing (paritial block with missing at both start and end
	!
	! ...|...OOOOOOOOO....|...
	!        A        A
	!        |        |
	!       inp     inp+len
	!
	!    - inp is NOT 16-byte aligned.
	!    - (inp+len) is NOT 16-byte aligned.
	!    - (inp+len) falls into the same block as inp.
	!    - len=0 case is also handled properly (though not so fast)
	!
	!   Reg.        Input           Output          Use
	!-------------------------------------------------------------------
	!   r0          const48         const48
	!   r3          index           index+headerCount
	!   r4          inp             inp+headerCount*2
	!   r5          outp            outp+headerCount
	!   r6          (len)           len
	!   r7          (maxChar)       maxChar
	!   r8          const16         const16
	!   r9          const32         const32
	!   r10         headerCount     headerCount
	!   r11         (blockCount)    blockCount
	!   r12         (trailerCount)  trailerCount
	!
	!   vr0         vmaxChars       vmaxChars
	!   vr1                         DESTROYED       vpat vopat
	!   vr2                         DESTROYED       vin0 vcmp0 vcmp01 vcmp01_masked dummy
	!   vr3                         DESTROYED       vin1 vcmp1 vomask
	!   vr4                         DESTROYED       vin2 vorig vmask_right
	!   vr5                         DESTROYED       v0 vout/vout_shift/vout_sel
	!   vr6                         DESTROYED       v1 vconst_0x0f
	!
	! Exceptional case: Exit to L.doScalar
	!   r3     cur. index
	!   r4     cur. inp
	!   r5     our. outp
	!   r6     len
	!   r7     maxChar
L.partialVector010:
    	lvsl 	vr1, r0, r4		! vpat = lvsl(0, inp)
	lvx 	vr2, r0, r4		! vin0 = *(vector *)inp
	lvx 	vr3, r8, r4		! vin1 = *((vector *)inp + 1)
	lvx 	vr4, r9, r4		! vin2 = *((vector *)inp + 2)
	vperm 	vr5, vr2, vr3, vr1	! v0 = perm(vin0, vin1, vpat)
	vperm 	vr6, vr3, vr4, vr1  	! v1 = perm(vin1, vin2, vpat)
	vcmpgtuh vr2, vr5, vr0		! vcmp0 = vec_cmpgt(v0, vmaxChars)
	vcmpgtuh vr3, vr6, vr0		! vcmp1 = vec_cmpgt(v1, vmaxChars)
	vpkuhum vr2,vr2,vr3		! vcmp01 = vec_pack(vcmp0, vcmp1)   ! left adjusted packed comp. result
	lvsr	vr1, r0, r5		! vopat = lvsr(0, output)
	vperm	vr2, vr2, vr2, vr1	! vcomp01 = vec_perm(vcmp01, vcmp01, vopat) Adjust packed compare result
	vpkuhum	vr5, vr5, vr6		! vout = pack(v0, v1)		    ! left adjusted packed result
	vspltisb vr6, 15		! vconst_0x0f = vec_splat_u8(15)
	vcmpgtub vr3, vr1, vr6		! vomask = vec_cmpgt(vopat, vconst_0x0f) (output&15)"00" . (16-(output&15))"ff"
	! specific to partialBlock
	lvsr	vr4, r6, r5		! vmask_right = lvsr(len, outp)
	vcmpgtub vr4, vr4, vr6		! vmask_right = vec_cmpgtub(vmask_right, vconst_0x0f)
	vandc	vr3, vr3, vr4		! vomask = vec_andc(vomask, vmask_right)
	! end of specific to partialBlock
	vand    vr2, vr2, vr3		! vcmp01_masked = vec_and(vcmp01, vomask)
	vcmpgtub.   vr2,vr2,vr6         ! if (vec_any_gt(vcmp01_masked,vconst_0x0f))...
	bc 	BO_IF_NOT_2, CR6_EQ, L.doScalar	! Yes, do scalar processing (statically predicted as unlikely)
	vperm	vr5, vr5, vr5, vr1	! vout = vec_perm(vout, vout, vopat). Adjust packed result
	lvx	vr4, r0, r5		! vorig = vec_ld(0, outp)
	vsel	vr5, vr4, vr5, vr3	! vout = vec_sel(vorig, vout, vomask)
	!!add 	r3, r3, r10		! index += headerCount	    SCHED:Can be moved anywhere in this macro
	add 	r3, r3, r6		! index += len		    SCHED:Can be moved anywhere in this macro
	!!add 	r4, r4, r10		! inp += 2 * headerCount    SCHED:anywhere after the 3rd lvx
	!!add 	r4, r4, r10		!
	stvx 	vr5, r0, r5		! *outp = vout
	!!add 	r5, r5, r10		! outp += headerCount

	! Return to the caller
	addi 	r3, r3, -1		! index - 1
	bclr	BO_ALWAYS, CR0_EQ

!----------------------------------------------------------------------
! end of partialVectr010
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! entry doScalar
!----------------------------------------------------------------------
	! doScalar    Generic and slow routine
	!
	!   Reg.        Input           Output          Use
	!-------------------------------------------------------------------
	!   r3          index           result
	!   r4          inp             DESTROYED
	!   r5          outp            DESTROYED
	!   r6          len             DESTROYED       count ch
	!   r7          maxChar         maxChar
L.doScalar4: 				! rewind four chars. before start
	addi	r5, r5, -32
L.doScalar3: 				! rewind three chars. before start
	addi	r5, r5, -32
L.doScalar2:				! rewind two chars. before start
	addi	r5, r5, -32
L.doScalar1:
	addi	r5, r5, -32		! rewind one char. before start
L.doScalar0:
L.doScalar:
	subf. 	r6, r3, r6		! (count = len - index) == 0 ?
	bc 	BO_IF_2,CR0_EQ, L.doScalarExit	! Yes, exit immediately (statically predicted as unlikely)
	mtctr 	r6			! CTR = count
	addi 	r5, r5, -1		! outp--
	addi 	r4, r4, -2		! inp--
L.doScalarLoop:
	lhzu 	r6, 2(r4)		! ch = *++inp
	cmplw 	cr0, r6, r7		! ch > maxChar ?
	bc 	BO_IF_2,CR0_GT, L.doScalarExit	! Yes, we have found an invalid char. (statically predicted as unlikely)
	stbu 	r6,1(r5)		! *++outp = ch
	addi 	r3, r3, 1		! index++
	bdnz 	L.doScalarLoop		! Decrement CTR and continue loop if not zero
L.doScalarExit:
L.doNull:
	addi 	r3, r3, -1		! return (index - 1)
	bclr	BO_ALWAYS, CR0_EQ
!----------------------------------------------------------------------
! end of doScalar
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! Handlers
!----------------------------------------------------------------------
	.align	5
L.vector000000:
	macroArrayTranslate(`0',`0',`0',`0',`0',`0')
	.align	5
L.vector000001:
	macroArrayTranslate(`0',`0',`0',`0',`0',`1')
	.align	5
L.vector000010:
	macroArrayTranslate(`0',`0',`0',`0',`1',`0')
	.align	5
L.vector000011:
	macroArrayTranslate(`0',`0',`0',`0',`1',`1')
	.align	5
L.vector000100:
	macroArrayTranslate(`0',`0',`0',`1',`0',`0')
	.align	5
L.vector000101:
	macroArrayTranslate(`0',`0',`0',`1',`0',`1')
	.align	5
L.vector000110:
	macroArrayTranslate(`0',`0',`0',`1',`1',`0')
	.align	5
L.vector000111:
	macroArrayTranslate(`0',`0',`0',`1',`1',`1')
	.align	5
L.vector001000:
	macroArrayTranslate(`0',`0',`1',`0',`0',`0')
	.align	5
L.vector001001:
	macroArrayTranslate(`0',`0',`1',`0',`0',`1')
	.align	5
L.vector001010:
	macroArrayTranslate(`0',`0',`1',`0',`1',`0')
	.align	5
L.vector001011:
	macroArrayTranslate(`0',`0',`1',`0',`1',`1')
	.align	5
L.vector001100:
	macroArrayTranslate(`0',`0',`1',`1',`0',`0')
	.align	5
L.vector001101:
	macroArrayTranslate(`0',`0',`1',`1',`0',`1')
	.align	5
L.vector001110:
	macroArrayTranslate(`0',`0',`1',`1',`1',`0')
	.align	5
L.vector001111:
	macroArrayTranslate(`0',`0',`1',`1',`1',`1')
	.align	5
L.vector010000:
	macroArrayTranslate(`0',`1',`0',`0',`0',`0')
	.align	5
L.vector010001:
	macroArrayTranslate(`0',`1',`0',`0',`0',`1')
	.align	5
L.vector010010:
	macroArrayTranslate(`0',`1',`0',`0',`1',`0')
	.align	5
L.vector010011:
	macroArrayTranslate(`0',`1',`0',`0',`1',`1')
	.align	5
L.vector010100:
	macroArrayTranslate(`0',`1',`0',`1',`0',`0')
	.align	5
L.vector010101:
	macroArrayTranslate(`0',`1',`0',`1',`0',`1')
	.align	5
L.vector010110:
	macroArrayTranslate(`0',`1',`0',`1',`1',`0')
	.align	5
L.vector010111:
	macroArrayTranslate(`0',`1',`0',`1',`1',`1')
	.align	5
L.vector011000:
	macroArrayTranslate(`0',`1',`1',`0',`0',`0')
	.align	5
L.vector011001:
	macroArrayTranslate(`0',`1',`1',`0',`0',`1')
	.align	5
L.vector011010:
	macroArrayTranslate(`0',`1',`1',`0',`1',`0')
	.align	5
L.vector011011:
	macroArrayTranslate(`0',`1',`1',`0',`1',`1')
	.align	5
L.vector011100:
	macroArrayTranslate(`0',`1',`1',`1',`0',`0')
	.align	5
L.vector011101:
	macroArrayTranslate(`0',`1',`1',`1',`0',`1')
	.align	5
L.vector011110:
	macroArrayTranslate(`0',`1',`1',`1',`1',`0')
	.align	5
L.vector011111:
	macroArrayTranslate(`0',`1',`1',`1',`1',`1')
!--
	.align	5
L.vector100000:
	macroArrayTranslate(`1',`0',`0',`0',`0',`0')
	.align	5
L.vector100001:
	macroArrayTranslate(`1',`0',`0',`0',`0',`1')
	.align	5
L.vector100010:
	macroArrayTranslate(`1',`0',`0',`0',`1',`0')
	.align	5
L.vector100011:
	macroArrayTranslate(`1',`0',`0',`0',`1',`1')
	.align	5
L.vector100100:
	macroArrayTranslate(`1',`0',`0',`1',`0',`0')
	.align	5
L.vector100101:
	macroArrayTranslate(`1',`0',`0',`1',`0',`1')
	.align	5
L.vector100110:
	macroArrayTranslate(`1',`0',`0',`1',`1',`0')
	.align	5
L.vector100111:
	macroArrayTranslate(`1',`0',`0',`1',`1',`1')
	.align	5
L.vector101000:
	macroArrayTranslate(`1',`0',`1',`0',`0',`0')
	.align	5
L.vector101001:
	macroArrayTranslate(`1',`0',`1',`0',`0',`1')
	.align	5
L.vector101010:
	macroArrayTranslate(`1',`0',`1',`0',`1',`0')
	.align	5
L.vector101011:
	macroArrayTranslate(`1',`0',`1',`0',`1',`1')
	.align	5
L.vector101100:
	macroArrayTranslate(`1',`0',`1',`1',`0',`0')
	.align	5
L.vector101101:
	macroArrayTranslate(`1',`0',`1',`1',`0',`1')
	.align	5
L.vector101110:
	macroArrayTranslate(`1',`0',`1',`1',`1',`0')
	.align	5
L.vector101111:
	macroArrayTranslate(`1',`0',`1',`1',`1',`1')
	.align	5
L.vector110000:
	macroArrayTranslate(`1',`1',`0',`0',`0',`0')
	.align	5
L.vector110001:
	macroArrayTranslate(`1',`1',`0',`0',`0',`1')
	.align	5
L.vector110010:
	macroArrayTranslate(`1',`1',`0',`0',`1',`0')
	.align	5
L.vector110011:
	macroArrayTranslate(`1',`1',`0',`0',`1',`1')
	.align	5
L.vector110100:
	macroArrayTranslate(`1',`1',`0',`1',`0',`0')
	.align	5
L.vector110101:
	macroArrayTranslate(`1',`1',`0',`1',`0',`1')
	.align	5
L.vector110110:
	macroArrayTranslate(`1',`1',`0',`1',`1',`0')
	.align	5
L.vector110111:
	macroArrayTranslate(`1',`1',`0',`1',`1',`1')
	.align	5
L.vector111000:
	macroArrayTranslate(`1',`1',`1',`0',`0',`0')
	.align	5
L.vector111001:
	macroArrayTranslate(`1',`1',`1',`0',`0',`1')
	.align	5
L.vector111010:
	macroArrayTranslate(`1',`1',`1',`0',`1',`0')
	.align	5
L.vector111011:
	macroArrayTranslate(`1',`1',`1',`0',`1',`1')
	.align	5
L.vector111100:
	macroArrayTranslate(`1',`1',`1',`1',`0',`0')
	.align	5
L.vector111101:
	macroArrayTranslate(`1',`1',`1',`1',`0',`1')
	.align	5
L.vector111110:
	macroArrayTranslate(`1',`1',`1',`1',`1',`0')
	.align	5
L.vector111111:
	macroArrayTranslate(`1',`1',`1',`1',`1',`1')

!----------------------------------------------------------------------
! endof Handlers
!----------------------------------------------------------------------
    	endproc.__arrayTranslateTRTOSimpleVMX:
#endif

! .data section
#ifdef AIXPPC
	.toc
#if 0
   TOC__arrayTranslateLabelTable:
           .tc       __arrayTranslateLabelTable[TC],__arrayTranslateLabelTable

           .csect    __arrayTranslateTRTOSimpleVMX{DS}
           ADDR      .__arrayTranslateTRTOSimpleVMX
           ADDR      TOC{TC0}
           ADDR      0x00000000
   ! End   csect     __arrayTranslateTRTOSimpleVMX{DS}
#endif

	.csect    __arrayTranslateTRTO{DS}
	ADDR      .__arrayTranslateTRTO
	ADDR      TOC{TC0}
	ADDR      0x00000000
! End   csect     __arrayTranslateTRTO{DS}

	.csect    __arrayTranslateTRTO255{DS}
	ADDR      .__arrayTranslateTRTO255
	ADDR      TOC{TC0}
	ADDR      0x00000000
! End   csect     __arrayTranslateTRTO255{DS}

    .csect    __arrayTranslateTROT255{DS}
	ADDR      .__arrayTranslateTROT255
	ADDR      TOC{TC0}
	ADDR      0x00000000

! End   csect     __arrayTranslateTROT255{DS}
    .csect    __arrayTranslateTROT{DS}
	ADDR      .__arrayTranslateTROT
	ADDR      TOC{TC0}
	ADDR      0x00000000
! End   csect     __arrayTranslateTROT{DS}


#elif defined(LINUXPPC64)
#if 0
   TOC__arrayTranslateLabelTable:
           .tc       __arrayTranslateLabelTable[TC],__arrayTranslateLabelTable

#if !defined(__LITTLE_ENDIAN__)
           .section  ".opd","aw"
           .align    3
           .globl    __arrayTranslateTRTOSimpleVMX
           .size     __arrayTranslateTRTOSimpleVMX,24
   __arrayTranslateTRTOSimpleVMX:
           .quad     .__arrayTranslateTRTOSimpleVMX
           .quad     .TOC.@tocbase
           .long     0x00000000
           .long     0x00000000
#endif
#endif
	.section  ".toc"
#if !defined(__LITTLE_ENDIAN__)
	.section  ".opd","aw"
	.align    3
	.globl    __arrayTranslateTRTO
	.size     __arrayTranslateTRTO,24
__arrayTranslateTRTO:
	.quad     .__arrayTranslateTRTO
	.quad     .TOC.@tocbase
	.long     0x00000000
	.long     0x00000000
	.globl    __arrayTranslateTRTO255
	.size     __arrayTranslateTRTO255,24
__arrayTranslateTRTO255:
	.quad     .__arrayTranslateTRTO255
	.quad     .TOC.@tocbase
	.long     0x00000000
	.long     0x00000000
	.globl    __arrayTranslateTROT255
	.size     __arrayTranslateTROT255,24
__arrayTranslateTROT255:
	.quad     .__arrayTranslateTROT255
	.quad     .TOC.@tocbase
	.long     0x00000000
	.long     0x00000000
	.globl    __arrayTranslateTROT
	.size     __arrayTranslateTROT,24
__arrayTranslateTROT:
	.quad     .__arrayTranslateTROT
	.quad     .TOC.@tocbase
	.long     0x00000000
	.long     0x00000000
#endif
#endif

#if defined(AIXPPC)
	.csect    ArrayTranslateTRTOSimpleVMX_DATA{RW}

#elif defined(NEUTRINO)
   .data
#elif defined(LINUXPPC64)
	.section  ".data"
	.align	4
#if 0
   .type __arrayTranslateLabelTable,@object
   .size __arrayTranslateLabelTable,264
#endif
#endif

#if 0
__arrayTranslateLabelTable:
	ADDR	0xdead0000
	ADDR	0xdead0001
	ADDR	L.vector000010
	ADDR	L.vector000011
	ADDR	L.vector000100
	ADDR	L.vector000101
	ADDR	L.vector000110
	ADDR	L.vector000111
    ADDR	L.vector001000
	ADDR	L.vector001001
	ADDR	L.vector001010
	ADDR	L.vector001011
	ADDR	L.vector001100
	ADDR	L.vector001101
	ADDR	L.vector001110
	ADDR	L.vector001111
	ADDR	L.vector010000
	ADDR	L.vector010001
	ADDR	L.vector010010
	ADDR	L.vector010011
	ADDR	L.vector010100
	ADDR	L.vector010101
	ADDR	L.vector010110
	ADDR	L.vector010111
	ADDR	L.vector011000
	ADDR	L.vector011001
	ADDR	L.vector011010
	ADDR	L.vector011011
	ADDR	L.vector011100
	ADDR	L.vector011101
	ADDR	L.vector011110
	ADDR	L.vector011111

	ADDR	0xdead0020
	ADDR	0xdead0021
	ADDR	L.vector100010
	ADDR	L.vector100011
	ADDR	L.vector100100
	ADDR	L.vector100101
	ADDR	L.vector100110
	ADDR	L.vector100111
    ADDR	L.vector101000
	ADDR	L.vector101001
	ADDR	L.vector101010
	ADDR	L.vector101011
	ADDR	L.vector101100
	ADDR	L.vector101101
	ADDR	L.vector101110
	ADDR	L.vector101111
	ADDR	L.vector110000
	ADDR	L.vector110001
	ADDR	L.vector110010
	ADDR	L.vector110011
	ADDR	L.vector110100
	ADDR	L.vector110101
	ADDR	L.vector110110
	ADDR	L.vector110111
	ADDR	L.vector111000
	ADDR	L.vector111001
	ADDR	L.vector111010
	ADDR	L.vector111011
	ADDR	L.vector111100
	ADDR	L.vector111101
	ADDR	L.vector111110
	ADDR	L.vector111111

	ADDR	L.doNull
	ADDR	L.vector000001
	ADDR	0xdead0042
	ADDR	0xdead0043
	ADDR	0xdead0044
	ADDR	0xdead0045
	ADDR	0xdead0046
	ADDR	0xdead0047
	ADDR	0xdead0048
	ADDR	0xdead0049
	ADDR	0xdead004a
	ADDR	0xdead004b
	ADDR	0xdead004c
	ADDR	0xdead004d
	ADDR	0xdead004e
	ADDR	0xdead004f
	ADDR	0xdead0050
	ADDR	0xdead0051
	ADDR	0xdead0052
	ADDR	0xdead0053
	ADDR	0xdead0054
	ADDR	0xdead0055
	ADDR	0xdead0056
	ADDR	0xdead0057
	ADDR	0xdead0058
	ADDR	0xdead0059
	ADDR	0xdead005a
	ADDR	0xdead005b
	ADDR	0xdead005c
	ADDR	0xdead005d
	ADDR	0xdead005e
	ADDR	L.partialVector010

	ADDR	L.doNull
	ADDR	L.vector100001
	ADDR	0xdead0062
	ADDR	0xdead0063
	ADDR	0xdead0064
	ADDR	0xdead0065
	ADDR	0xdead0066
	ADDR	0xdead0067
	ADDR	0xdead0068
	ADDR	0xdead0069
	ADDR	0xdead006a
	ADDR	0xdead006b
	ADDR	0xdead006c
	ADDR	0xdead006d
	ADDR	0xdead006e
	ADDR	0xdead006f
	ADDR	0xdead0070
	ADDR	0xdead0071
	ADDR	0xdead0072
	ADDR	0xdead0073
	ADDR	0xdead0074
	ADDR	0xdead0075
	ADDR	0xdead0076
	ADDR	0xdead0077
	ADDR	0xdead0078
	ADDR	0xdead0079
	ADDR	0xdead007a
	ADDR	0xdead007b
	ADDR	0xdead007c
	ADDR	0xdead007d
	ADDR	0xdead007e
	ADDR	L.partialVector010
! End   csect    ArrayTranslateTRTOSimpleVMX_DATA{RW}
#endif
